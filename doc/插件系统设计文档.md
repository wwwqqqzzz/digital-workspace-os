# Digital Workspace OS — 插件系统设计文档

> 构建安全、灵活、易扩展的插件生态系统

---

## 一、设计目标

### 1.1 核心目标

1. **安全性第一**：插件运行在严格的沙箱中，无法访问敏感数据
2. **易于开发**：提供简洁的 API，降低插件开发门槛
3. **高性能**：插件不应显著影响应用性能
4. **可扩展性**：支持多种类型的插件（UI、自动化、工具）
5. **用户可控**：用户完全控制插件的安装、权限和行为

### 1.2 设计原则

```
权限最小化：插件默认无权限，需要明确申请
显式授权：用户必须明确授予权限
隔离运行：插件互不干扰，无法访问彼此数据
快速失败：插件错误不应影响主应用
可审计性：所有插件操作都应可追踪
```

---

## 二、插件架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                      Main Process                        │
│  ┌────────────────────────────────────────────────────┐ │
│  │              Plugin Host (主控制器)                  │ │
│  │  ├─ Plugin Loader (加载器)                          │ │
│  │  ├─ Plugin Manager (管理器)                         │ │
│  │  ├─ Permission Manager (权限管理)                   │ │
│  │  └─ API Bridge (API 桥接)                           │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                           ↕ IPC
┌─────────────────────────────────────────────────────────┐
│                   Plugin Sandbox (VM)                    │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Plugin Code (插件代码)                             │ │
│  │  - activate()                                       │ │
│  │  - deactivate()                                     │ │
│  │  - onEvent()                                        │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  Exposed API (受限 API):                                │
│  - workspace.*                                          │
│  - tab.*                                                │
│  - ui.*                                                 │
│  - storage.*                                            │
│  - http.* (如果有权限)                                  │
└─────────────────────────────────────────────────────────┘
```

---

### 2.2 插件生命周期

```
┌──────────┐
│ 已安装   │
└────┬─────┘
     │ enable()
     ↓
┌──────────┐
│ 加载中   │ ← 读取 manifest.json
└────┬─────┘   验证权限
     │         创建沙箱
     ↓
┌──────────┐
│ 已激活   │ ← 调用 activate()
└────┬─────┘   注册事件监听
     │         注入 UI 组件
     ↓
┌──────────┐
│ 运行中   │ ← 响应事件
└────┬─────┘   执行操作
     │
     │ disable() / error
     ↓
┌──────────┐
│ 已停止   │ ← 调用 deactivate()
└────┬─────┘   清理资源
     │         移除监听器
     ↓
┌──────────┐
│ 已卸载   │
└──────────┘
```

---

## 三、插件清单（manifest.json）

### 3.1 清单结构

```json
{
  "id": "com.example.my-plugin",
  "name": "My Awesome Plugin",
  "version": "1.0.0",
  "description": "A plugin that does something awesome",
  "author": {
    "name": "John Doe",
    "email": "john@example.com",
    "url": "https://example.com"
  },

  "main": "dist/index.js",
  "icon": "icon.png",

  "engines": {
    "workspace-os": ">=1.0.0"
  },

  "permissions": [
    "workspace.read",
    "tab.read",
    "tab.write",
    "storage",
    "http:https://api.example.com/*"
  ],

  "activationEvents": [
    "onStartup",
    "onWorkspaceActivated",
    "onCommand:myPlugin.doSomething"
  ],

  "contributes": {
    "commands": [
      {
        "command": "myPlugin.doSomething",
        "title": "Do Something Awesome",
        "shortcut": "Ctrl+Shift+A"
      }
    ],
    "sidebarItems": [
      {
        "id": "myPlugin.sidebar",
        "title": "My Plugin",
        "icon": "sidebar-icon.png"
      }
    ],
    "contextMenus": [
      {
        "id": "myPlugin.contextMenu",
        "title": "My Plugin Action",
        "contexts": ["tab", "workspace"]
      }
    ]
  },

  "keywords": ["productivity", "automation"],
  "license": "MIT",
  "homepage": "https://github.com/example/my-plugin",
  "repository": {
    "type": "git",
    "url": "https://github.com/example/my-plugin.git"
  }
}
```

---

### 3.3 权限声明

#### 可用权限列表

```typescript
enum PluginPermission {
  // Workspace 相关
  WORKSPACE_READ = "workspace.read", // 读取 Workspace 信息
  WORKSPACE_WRITE = "workspace.write", // 创建/修改 Workspace

  // Tab 相关
  TAB_READ = "tab.read", // 读取 Tab 信息
  TAB_WRITE = "tab.write", // 创建/修改 Tab
  TAB_EXECUTE = "tab.execute", // 在 Tab 中执行脚本

  // UI 相关
  UI_SIDEBAR = "ui.sidebar", // 添加侧边栏项
  UI_CONTEXT_MENU = "ui.contextMenu", // 添加右键菜单
  UI_NOTIFICATION = "ui.notification", // 显示通知
  UI_DIALOG = "ui.dialog", // 显示对话框

  // 存储
  STORAGE = "storage", // 本地存储（隔离）

  // 网络（需指定域名）
  HTTP = "http:<url-pattern>", // HTTP 请求

  // 系统
  CLIPBOARD = "clipboard", // 剪贴板访问
  FILESYSTEM_READ = "filesystem.read", // 文件系统读取
  FILESYSTEM_WRITE = "filesystem.write", // 文件系统写入

  // 高级权限（需特别审核）
  NATIVE = "native", // 调用 Native API
  WEBVIEW_INJECT = "webview.inject", // 注入 WebView
}
```

#### 权限申请示例

```json
{
  "permissions": [
    "workspace.read",
    "tab.read",
    "tab.write",
    "storage",
    "ui.sidebar",
    "ui.notification",
    "http:https://api.example.com/*",
    "http:https://*.github.com/*",
    "clipboard"
  ]
}
```

---

## 四、插件 API

### 4.1 核心 API

#### Workspace API

```typescript
namespace workspace {
  // 获取所有 Workspace
  function getAll(): Promise<Workspace[]>;

  // 获取当前活跃 Workspace
  function getActive(): Promise<Workspace | null>;

  // 获取指定 Workspace
  function get(id: string): Promise<Workspace | null>;

  // 创建 Workspace（需要 workspace.write 权限）
  function create(config: WorkspaceConfig): Promise<Workspace>;

  // 更新 Workspace（需要 workspace.write 权限）
  function update(id: string, updates: Partial<WorkspaceConfig>): Promise<void>;

  // 激活 Workspace
  function activate(id: string): Promise<void>;

  // 事件监听
  function onActivated(callback: (workspace: Workspace) => void): Disposable;
  function onCreated(callback: (workspace: Workspace) => void): Disposable;
  function onDeleted(callback: (workspaceId: string) => void): Disposable;
}
```

#### Tab API

```typescript
namespace tab {
  // 获取所有 Tab
  function getAll(workspaceId?: string): Promise<Tab[]>;

  // 获取当前活跃 Tab
  function getActive(): Promise<Tab | null>;

  // 创建 Tab（需要 tab.write 权限）
  function create(workspaceId: string, url: string): Promise<Tab>;

  // 关闭 Tab（需要 tab.write 权限）
  function close(tabId: string): Promise<void>;

  // 激活 Tab
  function activate(tabId: string): Promise<void>;

  // 导航到 URL（需要 tab.write 权限）
  function navigate(tabId: string, url: string): Promise<void>;

  // 在 Tab 中执行脚本（需要 tab.execute 权限）
  function executeScript(tabId: string, code: string): Promise<any>;

  // 注入 CSS（需要 tab.execute 权限）
  function injectCSS(tabId: string, css: string): Promise<void>;

  // 事件监听
  function onCreated(callback: (tab: Tab) => void): Disposable;
  function onActivated(callback: (tab: Tab) => void): Disposable;
  function onUpdated(callback: (tab: Tab) => void): Disposable;
  function onClosed(callback: (tabId: string) => void): Disposable;
}
```

#### UI API

```typescript
namespace ui {
  // 显示通知（需要 ui.notification 权限）
  function showNotification(options: NotificationOptions): void;

  // 显示对话框（需要 ui.dialog 权限）
  function showDialog(options: DialogOptions): Promise<DialogResult>;

  // 注册侧边栏项（需要 ui.sidebar 权限）
  function registerSidebarItem(config: SidebarItemConfig): Disposable;

  // 注册右键菜单项（需要 ui.contextMenu 权限）
  function registerContextMenuItem(config: ContextMenuItemConfig): Disposable;

  // 注册命令
  function registerCommand(command: string, callback: () => void): Disposable;

  // 显示快速选择器
  function showQuickPick<T>(
    items: T[],
    options?: QuickPickOptions
  ): Promise<T | null>;

  // 显示输入框
  function showInputBox(options: InputBoxOptions): Promise<string | null>;
}

interface NotificationOptions {
  title: string;
  body: string;
  icon?: string;
  actions?: Array<{ label: string; action: () => void }>;
}

interface DialogOptions {
  type: "info" | "warning" | "error" | "question";
  title: string;
  message: string;
  buttons?: string[];
  defaultButton?: number;
}

interface SidebarItemConfig {
  id: string;
  title: string;
  icon: string;
  onClick: () => void;
}

interface ContextMenuItemConfig {
  id: string;
  label: string;
  contexts: Array<"workspace" | "tab">;
  onClick: (context: MenuContext) => void;
}
```

#### Storage API

```typescript
namespace storage {
  // 获取数据（自动命名空间隔离）
  function get<T>(key: string): Promise<T | null>;

  // 设置数据
  function set<T>(key: string, value: T): Promise<void>;

  // 删除数据
  function delete(key: string): Promise<void>;

  // 清空所有数据
  function clear(): Promise<void>;

  // 获取所有键
  function keys(): Promise<string[]>;

  // 监听变化
  function onChanged(callback: (changes: StorageChanges) => void): Disposable;
}

interface StorageChanges {
  [key: string]: {
    oldValue?: any;
    newValue?: any;
  };
}
```

#### HTTP API

```typescript
namespace http {
  // 发起 HTTP 请求（需要 http 权限，且 URL 必须匹配权限声明）
  function fetch(url: string, options?: RequestInit): Promise<Response>;

  // GET 请求
  function get(url: string, options?: RequestOptions): Promise<any>;

  // POST 请求
  function post(url: string, data: any, options?: RequestOptions): Promise<any>;
}

interface RequestOptions {
  headers?: Record<string, string>;
  timeout?: number;
}
```

#### Clipboard API

```typescript
namespace clipboard {
  // 读取剪贴板（需要 clipboard 权限）
  function readText(): Promise<string>;

  // 写入剪贴板（需要 clipboard 权限）
  function writeText(text: string): Promise<void>;
}
```

---

### 4.2 工具类型

```typescript
// Disposable：可释放的资源
interface Disposable {
  dispose(): void;
}

// 创建 Disposable 的工具函数
function createDisposable(disposeFunction: () => void): Disposable {
  return {
    dispose: disposeFunction,
  };
}

// 示例：注册事件监听器
const listener = workspace.onActivated((ws) => {
  console.log("Workspace activated:", ws.name);
});

// 清理时调用
listener.dispose();
```

---

## 五、插件开发

### 5.1 插件模板

```typescript
// src/index.ts

import { PluginAPI } from "@workspace-os/plugin-api";

// 插件激活时调用
export async function activate(api: PluginAPI) {
  console.log("Plugin activated!");

  // 注册命令
  const commandDisposable = api.ui.registerCommand(
    "myPlugin.helloWorld",
    () => {
      api.ui.showNotification({
        title: "Hello",
        body: "Hello from my plugin!",
      });
    }
  );

  // 监听 Workspace 激活事件
  const workspaceDisposable = api.workspace.onActivated(async (workspace) => {
    console.log("Workspace activated:", workspace.name);

    // 保存到存储
    await api.storage.set("lastActiveWorkspace", workspace.id);
  });

  // 返回清理函数
  return {
    deactivate: () => {
      commandDisposable.dispose();
      workspaceDisposable.dispose();
    },
  };
}

// 插件停用时调用
export function deactivate() {
  console.log("Plugin deactivated!");
}
```

---

### 5.2 开发工具链

#### package.json

```json
{
  "name": "my-awesome-plugin",
  "version": "1.0.0",
  "description": "An awesome plugin for Workspace OS",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "package": "vsce package",
    "test": "jest"
  },
  "devDependencies": {
    "@workspace-os/plugin-api": "^1.0.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "jest": "^29.0.0"
  }
}
```

#### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

---

### 5.3 调试插件

```typescript
// 开发模式：启用插件热重载
class PluginDevServer {
  private watcher: FSWatcher | null = null;

  startWatching(pluginPath: string): void {
    this.watcher = fs.watch(
      pluginPath,
      { recursive: true },
      (event, filename) => {
        if (filename?.endsWith(".js")) {
          console.log("Plugin changed, reloading...");
          this.reloadPlugin(pluginPath);
        }
      }
    );
  }

  async reloadPlugin(pluginPath: string): Promise<void> {
    // 1. 停用旧插件
    await pluginHost.unload(pluginPath);

    // 2. 清除 require 缓存
    Object.keys(require.cache).forEach((key) => {
      if (key.startsWith(pluginPath)) {
        delete require.cache[key];
      }
    });

    // 3. 重新加载
    await pluginHost.load(pluginPath);

    console.log("Plugin reloaded successfully");
  }

  stopWatching(): void {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }
  }
}

// 在主进程启动开发服务器
if (isDevelopment) {
  const devServer = new PluginDevServer();
  devServer.startWatching(path.join(__dirname, "../plugins/my-plugin"));
}
```

---

## 六、安全机制

### 6.1 沙箱隔离

```typescript
import vm from "vm";

class PluginSandbox {
  private context: vm.Context;

  constructor(pluginId: string, api: PluginAPI) {
    // 创建受限的上下文
    this.context = vm.createContext({
      // 基础全局对象
      console: this.createSafeConsole(pluginId),
      setTimeout,
      setInterval,
      clearTimeout,
      clearInterval,

      // 插件 API
      workspace: api.workspace,
      tab: api.tab,
      ui: api.ui,
      storage: api.storage,
      http: api.http,
      clipboard: api.clipboard,

      // 工具函数
      Buffer: Buffer,
      URL: URL,

      // 禁止访问的对象
      require: undefined,
      process: undefined,
      __dirname: undefined,
      __filename: undefined,
      global: undefined,
      module: undefined,
      exports: undefined,
    });
  }

  // 在沙箱中执行代码
  run(code: string, filename: string): any {
    try {
      const script = new vm.Script(code, {
        filename,
        timeout: 5000, // 5 秒超时
      });

      return script.runInContext(this.context);
    } catch (error) {
      console.error(`Error running plugin code:`, error);
      throw error;
    }
  }

  // 创建安全的 console 对象
  private createSafeConsole(pluginId: string) {
    return {
      log: (...args: any[]) => console.log(`[Plugin:${pluginId}]`, ...args),
      error: (...args: any[]) => console.error(`[Plugin:${pluginId}]`, ...args),
      warn: (...args: any[]) => console.warn(`[Plugin:${pluginId}]`, ...args),
      info: (...args: any[]) => console.info(`[Plugin:${pluginId}]`, ...args),
      debug: (...args: any[]) => console.debug(`[Plugin:${pluginId}]`, ...args),
    };
  }
}
```

---

### 6.2 权限管理

```typescript
class PermissionManager {
  private grantedPermissions: Map<string, Set<string>> = new Map();

  // 请求权限（首次使用时弹窗询问）
  async requestPermission(
    pluginId: string,
    permission: PluginPermission
  ): Promise<boolean> {
    // 检查是否已授权
    if (this.hasPermission(pluginId, permission)) {
      return true;
    }

    // 弹窗询问用户
    const result = await dialog.showMessageBox({
      type: "question",
      buttons: ["Allow", "Deny", "Allow Once"],
      defaultButton: 0,
      title: "Permission Request",
      message: `Plugin "${pluginId}" requests permission: ${permission}`,
      detail: this.getPermissionDescription(permission),
    });

    if (result.response === 0) {
      // 永久授权
      this.grantPermission(pluginId, permission);
      this.savePermissions();
      return true;
    } else if (result.response === 2) {
      // 仅此次允许
      return true;
    }

    return false;
  }

  // 检查权限
  hasPermission(pluginId: string, permission: string): boolean {
    const permissions = this.grantedPermissions.get(pluginId);
    return permissions?.has(permission) || false;
  }

  // 授予权限
  private grantPermission(pluginId: string, permission: string): void {
    if (!this.grantedPermissions.has(pluginId)) {
      this.grantedPermissions.set(pluginId, new Set());
    }
    this.grantedPermissions.get(pluginId)!.add(permission);
  }

  // 撤销权限
  revokePermission(pluginId: string, permission: string): void {
    this.grantedPermissions.get(pluginId)?.delete(permission);
    this.savePermissions();
  }

  // 撤销所有权限
  revokeAllPermissions(pluginId: string): void {
    this.grantedPermissions.delete(pluginId);
    this.savePermissions();
  }

  // 获取权限描述
  private getPermissionDescription(permission: string): string {
    const descriptions: Record<string, string> = {
      "workspace.read": "Read workspace information",
      "workspace.write": "Create and modify workspaces",
      "tab.read": "Read tab information",
      "tab.write": "Create and modify tabs",
      "tab.execute": "Execute scripts in tabs",
      storage: "Store data locally",
      http: "Make HTTP requests to external servers",
      clipboard: "Access clipboard",
      "ui.notification": "Show notifications",
    };

    return descriptions[permission] || "Unknown permission";
  }

  // 持久化权限
  private savePermissions(): void {
    const data: Record<string, string[]> = {};
    for (const [pluginId, permissions] of this.grantedPermissions) {
      data[pluginId] = Array.from(permissions);
    }

    fs.writeFileSync(
      path.join(app.getPath("userData"), "plugin-permissions.json"),
      JSON.stringify(data, null, 2)
    );
  }

  // 加载权限
  loadPermissions(): void {
    try {
      const data = fs.readFileSync(
        path.join(app.getPath("userData"), "plugin-permissions.json"),
        "utf-8"
      );

      const parsed: Record<string, string[]> = JSON.parse(data);
      for (const [pluginId, permissions] of Object.entries(parsed)) {
        this.grantedPermissions.set(pluginId, new Set(permissions));
      }
    } catch (err) {
      // 文件不存在或解析失败，使用空权限
    }
  }
}
```

---

### 6.3 资源限制

```typescript
class ResourceLimiter {
  private limits = {
    maxMemoryMB: 100, // 每个插件最多 100MB
    maxCPUPercent: 10, // 每个插件最多 10% CPU
    maxStorageKB: 10 * 1024, // 每个插件最多 10MB 存储
    maxHTTPRequestsPerMinute: 60, // 每分钟最多 60 个 HTTP 请求
  };

  private httpRequestCounts: Map<string, number[]> = new Map();

  // 检查 HTTP 请求限流
  async checkHTTPRateLimit(pluginId: string): Promise<boolean> {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;

    // 获取最近一分钟的请求时间戳
    const timestamps = this.httpRequestCounts.get(pluginId) || [];
    const recentRequests = timestamps.filter((t) => t > oneMinuteAgo);

    if (recentRequests.length >= this.limits.maxHTTPRequestsPerMinute) {
      throw new Error(
        `Rate limit exceeded: ${this.limits.maxHTTPRequestsPerMinute} requests per minute`
      );
    }

    // 记录此次请求
    recentRequests.push(now);
    this.httpRequestCounts.set(pluginId, recentRequests);

    return true;
  }

  // 检查内存使用
  async checkMemoryUsage(pluginId: string): Promise<void> {
    // 获取插件进程的内存使用（如果是独立进程）
    // 或者通过 V8 heap statistics 估算

    const memoryUsage = await this.getPluginMemoryUsage(pluginId);

    if (memoryUsage > this.limits.maxMemoryMB * 1024 * 1024) {
      console.warn(
        `Plugin ${pluginId} exceeds memory limit: ${
          memoryUsage / 1024 / 1024
        }MB`
      );

      // 可以选择暂停或卸载插件
      await pluginHost.unload(pluginId);

      throw new Error(`Memory limit exceeded: ${this.limits.maxMemoryMB}MB`);
    }
  }

  // 检查存储使用
  async checkStorageUsage(pluginId: string): Promise<void> {
    const storageSize = await this.getPluginStorageSize(pluginId);

    if (storageSize > this.limits.maxStorageKB * 1024) {
      throw new Error(`Storage limit exceeded: ${this.limits.maxStorageKB}KB`);
    }
  }

  private async getPluginMemoryUsage(pluginId: string): Promise<number> {
    // 实现内存使用检测
    return 0;
  }

  private async getPluginStorageSize(pluginId: string): Promise<number> {
    // 计算插件存储的数据大小
    const keys = await storageManager.getPluginKeys(pluginId);
    let totalSize = 0;

    for (const key of keys) {
      const value = await storageManager.get(key);
      totalSize += JSON.stringify(value).length;
    }

    return totalSize;
  }
}
```

---

## 七、插件加载与管理

### 7.1 Plugin Host

```typescript
class PluginHost {
  private plugins: Map<string, LoadedPlugin> = new Map();
  private permissionManager: PermissionManager;
  private resourceLimiter: ResourceLimiter;

  constructor() {
    this.permissionManager = new PermissionManager();
    this.resourceLimiter = new ResourceLimiter();
    this.permissionManager.loadPermissions();
  }

  // 加载插件
  async load(pluginPath: string): Promise<void> {
    try {
      // 1. 读取 manifest
      const manifest = await this.readManifest(pluginPath);

      // 2. 验证 manifest
      this.validateManifest(manifest);

      // 3. 检查版本兼容性
      if (!this.isCompatible(manifest.engines["workspace-os"])) {
        throw new Error(
          `Plugin requires workspace-os ${manifest.engines["workspace-os"]}`
        );
      }

      // 4. 检查是否已加载
      if (this.plugins.has(manifest.id)) {
        throw new Error(`Plugin ${manifest.id} is already loaded`);
      }

      // 5. 创建插件 API
      const api = this.createPluginAPI(manifest);

      // 6. 创建沙箱
      const sandbox = new PluginSandbox(manifest.id, api);

      // 7. 加载插件代码
      const mainPath = path.join(pluginPath, manifest.main);
      const code = await fs.promises.readFile(mainPath, "utf-8");

      // 8. 在沙箱中执行
      const pluginModule = sandbox.run(code, mainPath);

      // 9. 激活插件
      const deactivate = await pluginModule.activate(api);

      // 10. 保存插件实例
      this.plugins.set(manifest.id, {
        manifest,
        path: pluginPath,
        sandbox,
        deactivate: deactivate?.deactivate || pluginModule.deactivate,
        api,
      });

      console.log(`Plugin loaded: ${manifest.name} v${manifest.version}`);
    } catch (error) {
      console.error(`Failed to load plugin:`, error);
      throw error;
    }
  }

  // 卸载插件
  async unload(pluginId: string): Promise<void> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    try {
      // 1. 调用停用函数
      if (plugin.deactivate) {
        await plugin.deactivate();
      }

      // 2. 清理资源
      plugin.api.dispose();

      // 3. 移除插件
      this.plugins.delete(pluginId);

      console.log(`Plugin unloaded: ${plugin.manifest.name}`);
    } catch (error) {
      console.error(`Failed to unload plugin:`, error);
      throw error;
    }
  }

  // 重新加载插件
  async reload(pluginId: string): Promise<void> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    const pluginPath = plugin.path;
    await this.unload(pluginId);
    await this.load(pluginPath);
  }

  // 获取所有插件
  getAllPlugins(): PluginInfo[] {
    return Array.from(this.plugins.values()).map((p) => ({
      id: p.manifest.id,
      name: p.manifest.name,
      version: p.manifest.version,
      description: p.manifest.description,
      author: p.manifest.author,
      enabled: true,
    }));
  }

  // 创建插件 API
  private createPluginAPI(manifest: PluginManifest): PluginAPI {
    const pluginId = manifest.id;
    const permissions = manifest.permissions || [];
    const disposables: Disposable[] = [];

    const api: PluginAPI = {
      // Workspace API
      workspace: {
        getAll: async () => {
          this.checkPermission(pluginId, "workspace.read");
          return await workspaceManager.list();
        },

        getActive: async () => {
          this.checkPermission(pluginId, "workspace.read");
          return workspaceManager.getActive();
        },

        get: async (id: string) => {
          this.checkPermission(pluginId, "workspace.read");
          return await workspaceManager.get(id);
        },

        create: async (config: WorkspaceConfig) => {
          this.checkPermission(pluginId, "workspace.write");
          return await workspaceManager.create(config);
        },

        update: async (id: string, updates: any) => {
          this.checkPermission(pluginId, "workspace.write");
          return await workspaceManager.update(id, updates);
        },

        activate: async (id: string) => {
          this.checkPermission(pluginId, "workspace.read");
          return await workspaceManager.activate(id);
        },

        onActivated: (callback: any) => {
          this.checkPermission(pluginId, "workspace.read");
          const listener = workspaceManager.on("workspace-activated", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },

        onCreated: (callback: any) => {
          this.checkPermission(pluginId, "workspace.read");
          const listener = workspaceManager.on("workspace-created", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },

        onDeleted: (callback: any) => {
          this.checkPermission(pluginId, "workspace.read");
          const listener = workspaceManager.on("workspace-deleted", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },
      },

      // Tab API
      tab: {
        getAll: async (workspaceId?: string) => {
          this.checkPermission(pluginId, "tab.read");
          return tabManager.getTabsForWorkspace(workspaceId);
        },

        getActive: async () => {
          this.checkPermission(pluginId, "tab.read");
          return tabManager.getActiveTab();
        },

        create: async (workspaceId: string, url: string) => {
          this.checkPermission(pluginId, "tab.write");
          return await tabManager.create(workspaceId, url);
        },

        close: async (tabId: string) => {
          this.checkPermission(pluginId, "tab.write");
          return await tabManager.close(tabId);
        },

        activate: async (tabId: string) => {
          this.checkPermission(pluginId, "tab.read");
          return await tabManager.activate(tabId);
        },

        navigate: async (tabId: string, url: string) => {
          this.checkPermission(pluginId, "tab.write");
          return await tabManager.navigate(tabId, url);
        },

        executeScript: async (tabId: string, code: string) => {
          this.checkPermission(pluginId, "tab.execute");
          const view = webViewPoolManager.getView(tabId);
          if (!view) throw new Error("Tab not found");
          return await view.webContents.executeJavaScript(code);
        },

        injectCSS: async (tabId: string, css: string) => {
          this.checkPermission(pluginId, "tab.execute");
          const view = webViewPoolManager.getView(tabId);
          if (!view) throw new Error("Tab not found");
          return await view.webContents.insertCSS(css);
        },

        onCreated: (callback: any) => {
          this.checkPermission(pluginId, "tab.read");
          const listener = tabManager.on("tab-created", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },

        onActivated: (callback: any) => {
          this.checkPermission(pluginId, "tab.read");
          const listener = tabManager.on("tab-activated", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },

        onUpdated: (callback: any) => {
          this.checkPermission(pluginId, "tab.read");
          const listener = tabManager.on("tab-updated", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },

        onClosed: (callback: any) => {
          this.checkPermission(pluginId, "tab.read");
          const listener = tabManager.on("tab-closed", callback);
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },
      },

      // UI API
      ui: {
        showNotification: (options: any) => {
          this.checkPermission(pluginId, "ui.notification");
          new Notification({
            title: `[${manifest.name}] ${options.title}`,
            body: options.body,
            icon: options.icon,
          }).show();
        },

        showDialog: async (options: any) => {
          this.checkPermission(pluginId, "ui.dialog");
          return await dialog.showMessageBox(options);
        },

        registerSidebarItem: (config: any) => {
          this.checkPermission(pluginId, "ui.sidebar");
          const disposable = uiManager.registerSidebarItem(pluginId, config);
          disposables.push(disposable);
          return disposable;
        },

        registerContextMenuItem: (config: any) => {
          this.checkPermission(pluginId, "ui.contextMenu");
          const disposable = uiManager.registerContextMenuItem(
            pluginId,
            config
          );
          disposables.push(disposable);
          return disposable;
        },

        registerCommand: (command: string, callback: any) => {
          const disposable = commandManager.register(
            pluginId,
            command,
            callback
          );
          disposables.push(disposable);
          return disposable;
        },

        showQuickPick: async (items: any[], options: any) => {
          return await uiManager.showQuickPick(items, options);
        },

        showInputBox: async (options: any) => {
          return await uiManager.showInputBox(options);
        },
      },

      // Storage API
      storage: {
        get: async (key: string) => {
          this.checkPermission(pluginId, "storage");
          await this.resourceLimiter.checkStorageUsage(pluginId);
          return await storageManager.getPluginData(pluginId, key);
        },

        set: async (key: string, value: any) => {
          this.checkPermission(pluginId, "storage");
          await this.resourceLimiter.checkStorageUsage(pluginId);
          return await storageManager.setPluginData(pluginId, key, value);
        },

        delete: async (key: string) => {
          this.checkPermission(pluginId, "storage");
          return await storageManager.deletePluginData(pluginId, key);
        },

        clear: async () => {
          this.checkPermission(pluginId, "storage");
          return await storageManager.clearPluginData(pluginId);
        },

        keys: async () => {
          this.checkPermission(pluginId, "storage");
          return await storageManager.getPluginKeys(pluginId);
        },

        onChanged: (callback: any) => {
          this.checkPermission(pluginId, "storage");
          const listener = storageManager.on(
            `plugin-storage-changed:${pluginId}`,
            callback
          );
          const disposable = { dispose: () => listener() };
          disposables.push(disposable);
          return disposable;
        },
      },

      // HTTP API
      http: {
        fetch: async (url: string, options: any) => {
          this.checkHTTPPermission(pluginId, url);
          await this.resourceLimiter.checkHTTPRateLimit(pluginId);
          return await fetch(url, options);
        },

        get: async (url: string, options: any) => {
          this.checkHTTPPermission(pluginId, url);
          await this.resourceLimiter.checkHTTPRateLimit(pluginId);
          const response = await fetch(url, { ...options, method: "GET" });
          return await response.json();
        },

        post: async (url: string, data: any, options: any) => {
          this.checkHTTPPermission(pluginId, url);
          await this.resourceLimiter.checkHTTPRateLimit(pluginId);
          const response = await fetch(url, {
            ...options,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...options?.headers,
            },
            body: JSON.stringify(data),
          });
          return await response.json();
        },
      },

      // Clipboard API
      clipboard: {
        readText: async () => {
          this.checkPermission(pluginId, "clipboard");
          return clipboard.readText();
        },

        writeText: async (text: string) => {
          this.checkPermission(pluginId, "clipboard");
          return clipboard.writeText(text);
        },
      },

      // 清理资源
      dispose: () => {
        disposables.forEach((d) => d.dispose());
      },
    };

    return api;
  }

  // 检查权限
  private checkPermission(pluginId: string, permission: string): void {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    const hasPermission = plugin.manifest.permissions?.includes(permission);
    if (!hasPermission) {
      throw new Error(
        `Plugin ${pluginId} does not have permission: ${permission}`
      );
    }

    // 检查用户是否已授权
    if (!this.permissionManager.hasPermission(pluginId, permission)) {
      // 在后台请求权限（会弹窗）
      this.permissionManager.requestPermission(
        pluginId,
        permission as PluginPermission
      );
    }
  }

  // 检查 HTTP 权限
  private checkHTTPPermission(pluginId: string, url: string): void {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) {
      throw new Error(`Plugin ${pluginId} not found`);
    }

    const httpPermissions = plugin.manifest.permissions?.filter((p) =>
      p.startsWith("http:")
    );
    if (!httpPermissions || httpPermissions.length === 0) {
      throw new Error(`Plugin ${pluginId} does not have http permission`);
    }

    // 检查 URL 是否匹配权限模式
    const allowed = httpPermissions.some((pattern) => {
      const regex = this.patternToRegex(pattern.replace("http:", ""));
      return regex.test(url);
    });

    if (!allowed) {
      throw new Error(`Plugin ${pluginId} is not allowed to access ${url}`);
    }
  }

  // 将权限模式转换为正则表达式
  private patternToRegex(pattern: string): RegExp {
    const escaped = pattern
      .replace(/[.+?^${}()|[\]\\]/g, "\\")
      .replace(/\*/g, ".*");
    return new RegExp(`^${escaped}$`);
  }

  // 读取 manifest
  private async readManifest(pluginPath: string): Promise<PluginManifest> {
    const manifestPath = path.join(pluginPath, "manifest.json");
    const content = await fs.promises.readFile(manifestPath, "utf-8");
    return JSON.parse(content);
  }

  // 验证 manifest
  private validateManifest(manifest: PluginManifest): void {
    const required = ["id", "name", "version", "main", "author", "engines"];
    for (const field of required) {
      if (!manifest[field as keyof PluginManifest]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    // 验证 ID 格式（反向域名）
    if (!/^[a-z0-9.-]+\.[a-z0-9-]+$/.test(manifest.id)) {
      throw new Error(`Invalid plugin id format: ${manifest.id}`);
    }

    // 验证版本号（语义化版本）
    if (!/^\d+\.\d+\.\d+/.test(manifest.version)) {
      throw new Error(`Invalid version format: ${manifest.version}`);
    }
  }

  // 检查版本兼容性
  private isCompatible(requiredVersion: string): boolean {
    const appVersion = app.getVersion();
    // 简化版本比较（实际应使用 semver 库）
    return appVersion >= requiredVersion;
  }
}

interface LoadedPlugin {
  manifest: PluginManifest;
  path: string;
  sandbox: PluginSandbox;
  deactivate?: () => void | Promise<void>;
  api: PluginAPI;
}

interface PluginManifest {
  id: string;
  name: string;
  version: string;
  description: string;
  main: string;
  author: {
    name: string;
    email?: string;
    url?: string;
  };
  engines: {
    "workspace-os": string;
  };
  permissions?: string[];
  [key: string]: any;
}

interface PluginAPI {
  workspace: any;
  tab: any;
  ui: any;
  storage: any;
  http: any;
  clipboard: any;
  dispose: () => void;
}
```

---

## 八、内置插件示例

### 8.1 广告拦截器插件

```typescript
// ad-blocker/src/index.ts

import { PluginAPI } from "@workspace-os/plugin-api";

const AD_DOMAINS = [
  "doubleclick.net",
  "googleadservices.com",
  "googlesyndication.com",
  "facebook.com/tr",
  // ... 更多广告域名
];

export async function activate(api: PluginAPI) {
  console.log("Ad Blocker activated");

  let blockedCount = 0;

  // 监听所有 Tab 创建
  const tabDisposable = api.tab.onCreated(async (tab: any) => {
    // 在每个新 Tab 中注入拦截脚本
    try {
      await api.tab.injectCSS(
        tab.id,
        `
        /* 隐藏常见广告元素 */
        [class*="ad-"],
        [id*="ad-"],
        .advertisement,
        .sponsored-content {
          display: none !important;
        }
      `
      );

      await api.tab.executeScript(
        tab.id,
        `
        // 拦截广告请求
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
          const url = args[0];
          if (${JSON.stringify(
            AD_DOMAINS
          )}.some(domain => url.includes(domain))) {
            console.log('Blocked ad request:', url);
            return Promise.reject(new Error('Blocked by Ad Blocker'));
          }
          return originalFetch.apply(this, args);
        };
      `
      );

      blockedCount++;
    } catch (error) {
      console.error("Failed to inject ad blocker:", error);
    }
  });

  // 注册命令显示统计
  const commandDisposable = api.ui.registerCommand(
    "adBlocker.showStats",
    () => {
      api.ui.showNotification({
        title: "Ad Blocker Stats",
        body: `Blocked ${blockedCount} ads in this session`,
      });
    }
  );

  return {
    deactivate: () => {
      tabDisposable.dispose();
      commandDisposable.dispose();
    },
  };
}

export function deactivate() {
  console.log("Ad Blocker deactivated");
}
```

```json
// ad-blocker/manifest.json
{
  "id": "com.workspace-os.ad-blocker",
  "name": "Ad Blocker",
  "version": "1.0.0",
  "description": "Block ads and trackers",
  "main": "dist/index.js",
  "author": {
    "name": "Workspace OS Team"
  },
  "engines": {
    "workspace-os": ">=1.0.0"
  },
  "permissions": ["tab.read", "tab.execute", "ui.notification"],
  "activationEvents": ["onStartup"],
  "icon": "icon.png"
}
```

---

### 8.2 自动登录插件

```typescript
// auto-login/src/index.ts

import { PluginAPI } from "@workspace-os/plugin-api";

interface LoginCredential {
  domain: string;
  username: string;
  password: string;
  usernameSelector: string;
  passwordSelector: string;
  submitSelector: string;
}

export async function activate(api: PluginAPI) {
  console.log("Auto Login activated");

  // 从存储加载凭据
  const credentials: LoginCredential[] =
    (await api.storage.get("credentials")) || [];

  // 监听 Tab 更新
  const disposable = api.tab.onUpdated(async (tab: any) => {
    const url = new URL(tab.url);
    const credential = credentials.find((c) => url.hostname.includes(c.domain));

    if (credential) {
      // 等待页面加载完成
      setTimeout(async () => {
        try {
          await api.tab.executeScript(
            tab.id,
            `
            (function() {
              const username = document.querySelector('${credential.usernameSelector}');
              const password = document.querySelector('${credential.passwordSelector}');
              const submit = document.querySelector('${credential.submitSelector}');
              
              if (username && password) {
                username.value = '${credential.username}';
                password.value = '${credential.password}';
                
                // 触发 change 事件
                username.dispatchEvent(new Event('input', { bubbles: true }));
                password.dispatchEvent(new Event('input', { bubbles: true }));
                
                if (submit) {
                  setTimeout(() => submit.click(), 500);
                }
                
                return true;
              }
              return false;
            })();
          `
          );

          api.ui.showNotification({
            title: "Auto Login",
            body: `Logged in to ${credential.domain}`,
          });
        } catch (error) {
          console.error("Auto login failed:", error);
        }
      }, 2000);
    }
  });

  // 注册添加凭据的命令
  const commandDisposable = api.ui.registerCommand(
    "autoLogin.addCredential",
    async () => {
      const domain = await api.ui.showInputBox({
        prompt: "Enter domain (e.g., example.com)",
      });

      if (!domain) return;

      const username = await api.ui.showInputBox({
        prompt: "Enter username",
      });

      if (!username) return;

      const password = await api.ui.showInputBox({
        prompt: "Enter password",
        password: true,
      });

      if (!password) return;

      credentials.push({
        domain,
        username,
        password,
        usernameSelector: 'input[type="email"], input[name="username"]',
        passwordSelector: 'input[type="password"]',
        submitSelector: 'button[type="submit"]',
      });

      await api.storage.set("credentials", credentials);

      api.ui.showNotification({
        title: "Auto Login",
        body: `Credential saved for ${domain}`,
      });
    }
  );

  return {
    deactivate: () => {
      disposable.dispose();
      commandDisposable.dispose();
    },
  };
}
```

---

### 8.3 Workspace 同步插件

```typescript
// workspace-sync/src/index.ts

import { PluginAPI } from "@workspace-os/plugin-api";

export async function activate(api: PluginAPI) {
  console.log("Workspace Sync activated");

  // 从存储读取配置
  const config = (await api.storage.get("config")) || {
    syncUrl: "",
    syncInterval: 5 * 60 * 1000, // 5 分钟
  };

  // 同步函数
  async function sync() {
    if (!config.syncUrl) return;

    try {
      // 获取所有 Workspace
      const workspaces = await api.workspace.getAll();

      // 上传到服务器
      const response = await api.http.post(config.syncUrl, {
        workspaces: workspaces.map((ws) => ({
          id: ws.id,
          name: ws.name,
          icon: ws.icon,
          color: ws.color,
          tabs: ws.tabs.map((t) => ({
            url: t.url,
            title: t.title,
          })),
        })),
        timestamp: Date.now(),
      });

      console.log("Sync completed:", response);

      api.ui.showNotification({
        title: "Workspace Sync",
        body: "Workspaces synced successfully",
      });
    } catch (error) {
      console.error("Sync failed:", error);
      api.ui.showNotification({
        title: "Workspace Sync",
        body: "Sync failed: " + error.message,
      });
    }
  }

  // 定期同步
  const intervalId = setInterval(sync, config.syncInterval);

  // 手动同步命令
  const commandDisposable = api.ui.registerCommand("workspaceSync.sync", sync);

  // 配置命令
  const configDisposable = api.ui.registerCommand(
    "workspaceSync.configure",
    async () => {
      const url = await api.ui.showInputBox({
        prompt: "Enter sync server URL",
        value: config.syncUrl,
      });

      if (url) {
        config.syncUrl = url;
        await api.storage.set("config", config);
        api.ui.showNotification({
          title: "Workspace Sync",
          body: "Configuration saved",
        });
      }
    }
  );

  return {
    deactivate: () => {
      clearInterval(intervalId);
      commandDisposable.dispose();
      configDisposable.dispose();
    },
  };
}
```

```json
// workspace-sync/manifest.json
{
  "id": "com.workspace-os.workspace-sync",
  "name": "Workspace Sync",
  "version": "1.0.0",
  "description": "Sync workspaces to cloud",
  "main": "dist/index.js",
  "author": {
    "name": "Workspace OS Team"
  },
  "engines": {
    "workspace-os": ">=1.0.0"
  },
  "permissions": [
    "workspace.read",
    "tab.read",
    "storage",
    "ui.notification",
    "http:https://*"
  ],
  "activationEvents": ["onStartup"],
  "contributes": {
    "commands": [
      {
        "command": "workspaceSync.sync",
        "title": "Sync Now"
      },
      {
        "command": "workspaceSync.configure",
        "title": "Configure Sync"
      }
    ]
  }
}
```

---

## 九、插件市场（后期）

### 9.1 市场架构

```
┌──────────────────────────────────────┐
│        Plugin Marketplace Web        │
│  ┌────────────────────────────────┐  │
│  │  - 插件列表                     │  │
│  │  - 搜索和筛选                   │  │
│  │  - 插件详情                     │  │
│  │  - 评分和评论                   │  │
│  │  - 下载统计                     │  │
│  └────────────────────────────────┘  │
└──────────────────────────────────────┘
                 ↕
┌──────────────────────────────────────┐
│       Plugin Marketplace API         │
│  - GET /plugins                      │
│  - GET /plugins/:id                  │
│  - POST /plugins (发布)              │
│  - GET /plugins/:id/download         │
│  - POST /plugins/:id/review          │
└──────────────────────────────────────┘
                 ↕
┌──────────────────────────────────────┐
│    Application (Plugin Manager)      │
│  - 浏览市场                          │
│  - 一键安装                          │
│  - 自动更新                          │
│  - 评分和反馈                        │
└──────────────────────────────────────┘
```

---

### 9.2 插件提交流程

```
1. 开发者开发插件
   ↓
2. 运行本地测试
   ↓
3. 打包插件 (.wsplugin 文件)
   ↓
4. 提交到市场审核
   ↓
5. 自动化检查：
   - 代码扫描（安全漏洞）
   - 权限审核
   - 性能测试
   ↓
6. 人工审核（如需要）
   ↓
7. 发布到市场
   ↓
8. 用户安装和使用
   ↓
9. 收集反馈和评分
   ↓
10. 持续更新和维护
```

---

### 9.3 插件审核标准

#### 安全检查

- ✅ 无恶意代码
- ✅ 无隐藏权限请求
- ✅ 无数据窃取行为
- ✅ 无远程代码执行
- ✅ 权限使用合理

#### 质量检查

- ✅ 代码质量良好
- ✅ 无明显 Bug
- ✅ 性能开销可接受
- ✅ 文档完整
- ✅ 遵循设计规范

#### 内容检查

- ✅ 无违法内容
- ✅ 无版权侵权
- ✅ 无虚假宣传
- ✅ 描述准确
- ✅ 截图真实

#### 用户体验

- ✅ 安装流程顺畅
- ✅ 配置界面友好
- ✅ 错误提示清晰
- ✅ 卸载干净彻底

---

## 十、插件打包与分发

### 10.1 插件打包格式

```typescript
// 插件打包工具
class PluginPackager {
  async pack(pluginDir: string, outputPath: string): Promise<void> {
    const manifest = await this.readManifest(pluginDir);

    // 验证 manifest
    this.validateManifest(manifest);

    // 创建 .wsplugin 文件（实际是 zip）
    const zip = new AdmZip();

    // 添加所有文件
    zip.addLocalFolder(pluginDir);

    // 添加元数据
    const metadata = {
      id: manifest.id,
      version: manifest.version,
      packaged_at: Date.now(),
      checksum: this.calculateChecksum(pluginDir),
    };

    zip.addFile(
      "_metadata.json",
      Buffer.from(JSON.stringify(metadata, null, 2))
    );

    // 写入文件
    zip.writeZip(outputPath);

    console.log(`Plugin packaged: ${outputPath}`);
  }

  async unpack(pluginFile: string, targetDir: string): Promise<void> {
    const zip = new AdmZip(pluginFile);

    // 读取元数据
    const metadataEntry = zip.getEntry("_metadata.json");
    if (!metadataEntry) {
      throw new Error("Invalid plugin package: missing metadata");
    }

    const metadata = JSON.parse(metadataEntry.getData().toString("utf-8"));

    // 验证校验和
    // ... (实现略)

    // 解压到目标目录
    zip.extractAllTo(targetDir, true);

    console.log(`Plugin unpacked: ${targetDir}`);
  }

  private calculateChecksum(dir: string): string {
    // 计算目录的 SHA256 校验和
    const crypto = require("crypto");
    const hash = crypto.createHash("sha256");

    // 递归读取所有文件并计算哈希
    // ... (实现略)

    return hash.digest("hex");
  }

  private async readManifest(dir: string): Promise<PluginManifest> {
    const manifestPath = path.join(dir, "manifest.json");
    const content = await fs.promises.readFile(manifestPath, "utf-8");
    return JSON.parse(content);
  }

  private validateManifest(manifest: PluginManifest): void {
    // 验证逻辑（与 PluginHost 中相同）
  }
}

// 使用示例
const packager = new PluginPackager();
await packager.pack("./my-plugin", "./my-plugin-1.0.0.wsplugin");
```

---

### 10.2 插件安装器

```typescript
class PluginInstaller {
  async install(pluginFile: string): Promise<void> {
    // 1. 解压到临时目录
    const tempDir = path.join(app.getPath("temp"), `plugin-${Date.now()}`);
    await fs.promises.mkdir(tempDir, { recursive: true });

    const packager = new PluginPackager();
    await packager.unpack(pluginFile, tempDir);

    // 2. 读取 manifest
    const manifest = await this.readManifest(tempDir);

    // 3. 检查是否已安装
    const pluginsDir = path.join(app.getPath("userData"), "plugins");
    const targetDir = path.join(pluginsDir, manifest.id);

    if (await this.exists(targetDir)) {
      // 检查版本
      const existingManifest = await this.readManifest(targetDir);

      if (
        this.compareVersions(manifest.version, existingManifest.version) <= 0
      ) {
        throw new Error(
          `Plugin ${manifest.id} v${existingManifest.version} is already installed`
        );
      }

      // 备份旧版本
      const backupDir = `${targetDir}.backup`;
      await fs.promises.rename(targetDir, backupDir);

      try {
        // 安装新版本
        await this.copyDir(tempDir, targetDir);
      } catch (error) {
        // 安装失败，恢复备份
        await fs.promises.rename(backupDir, targetDir);
        throw error;
      }

      // 删除备份
      await fs.promises.rm(backupDir, { recursive: true });
    } else {
      // 首次安装
      await this.copyDir(tempDir, targetDir);
    }

    // 4. 清理临时目录
    await fs.promises.rm(tempDir, { recursive: true });

    // 5. 加载插件
    await pluginHost.load(targetDir);

    console.log(`Plugin installed: ${manifest.name} v${manifest.version}`);
  }

  async uninstall(pluginId: string): Promise<void> {
    // 1. 卸载插件
    await pluginHost.unload(pluginId);

    // 2. 删除插件文件
    const pluginsDir = path.join(app.getPath("userData"), "plugins");
    const pluginDir = path.join(pluginsDir, pluginId);

    await fs.promises.rm(pluginDir, { recursive: true });

    // 3. 清理插件数据
    await storageManager.clearPluginData(pluginId);

    // 4. 撤销权限
    permissionManager.revokeAllPermissions(pluginId);

    console.log(`Plugin uninstalled: ${pluginId}`);
  }

  async update(pluginId: string): Promise<void> {
    // 1. 从市场获取最新版本
    const latestVersion = await this.fetchLatestVersion(pluginId);

    // 2. 下载插件包
    const pluginFile = await this.downloadPlugin(
      pluginId,
      latestVersion.version
    );

    // 3. 安装（会自动覆盖旧版本）
    await this.install(pluginFile);

    console.log(`Plugin updated: ${pluginId} to v${latestVersion.version}`);
  }

  private async exists(path: string): Promise<boolean> {
    try {
      await fs.promises.access(path);
      return true;
    } catch {
      return false;
    }
  }

  private compareVersions(v1: string, v2: string): number {
    const parts1 = v1.split(".").map(Number);
    const parts2 = v2.split(".").map(Number);

    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const p1 = parts1[i] || 0;
      const p2 = parts2[i] || 0;

      if (p1 > p2) return 1;
      if (p1 < p2) return -1;
    }

    return 0;
  }

  private async copyDir(src: string, dest: string): Promise<void> {
    await fs.promises.mkdir(dest, { recursive: true });
    const entries = await fs.promises.readdir(src, { withFileTypes: true });

    for (const entry of entries) {
      const srcPath = path.join(src, entry.name);
      const destPath = path.join(dest, entry.name);

      if (entry.isDirectory()) {
        await this.copyDir(srcPath, destPath);
      } else {
        await fs.promises.copyFile(srcPath, destPath);
      }
    }
  }

  private async readManifest(dir: string): Promise<PluginManifest> {
    const manifestPath = path.join(dir, "manifest.json");
    const content = await fs.promises.readFile(manifestPath, "utf-8");
    return JSON.parse(content);
  }

  private async fetchLatestVersion(pluginId: string): Promise<any> {
    // 从市场 API 获取最新版本信息
    const response = await fetch(
      `https://marketplace.workspace-os.com/api/plugins/${pluginId}/latest`
    );
    return await response.json();
  }

  private async downloadPlugin(
    pluginId: string,
    version: string
  ): Promise<string> {
    // 下载插件包
    const url = `https://marketplace.workspace-os.com/api/plugins/${pluginId}/download/${version}`;
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();

    const tempFile = path.join(
      app.getPath("temp"),
      `${pluginId}-${version}.wsplugin`
    );
    await fs.promises.writeFile(tempFile, Buffer.from(buffer));

    return tempFile;
  }
}
```

---

### 10.3 自动更新

```typescript
class PluginAutoUpdater {
  private checkInterval = 24 * 60 * 60 * 1000; // 24 小时
  private intervalId: NodeJS.Timeout | null = null;

  start(): void {
    this.check(); // 立即检查一次

    this.intervalId = setInterval(() => {
      this.check();
    }, this.checkInterval);
  }

  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  async check(): Promise<void> {
    console.log("Checking for plugin updates...");

    const installedPlugins = pluginHost.getAllPlugins();
    const updates: Array<{
      pluginId: string;
      currentVersion: string;
      latestVersion: string;
    }> = [];

    for (const plugin of installedPlugins) {
      try {
        const latest = await this.fetchLatestVersion(plugin.id);

        if (this.compareVersions(latest.version, plugin.version) > 0) {
          updates.push({
            pluginId: plugin.id,
            currentVersion: plugin.version,
            latestVersion: latest.version,
          });
        }
      } catch (error) {
        console.error(`Failed to check updates for ${plugin.id}:`, error);
      }
    }

    if (updates.length > 0) {
      this.notifyUpdates(updates);
    }
  }

  private notifyUpdates(updates: any[]): void {
    const message = updates
      .map((u) => `${u.pluginId}: ${u.currentVersion} → ${u.latestVersion}`)
      .join("\n");

    const notification = new Notification({
      title: "Plugin Updates Available",
      body: `${updates.length} plugin(s) can be updated:\n${message}`,
      actions: [
        { type: "button", text: "Update All" },
        { type: "button", text: "Later" },
      ],
    });

    notification.on("action", async (event, index) => {
      if (index === 0) {
        // 更新所有插件
        for (const update of updates) {
          try {
            await pluginInstaller.update(update.pluginId);
          } catch (error) {
            console.error(`Failed to update ${update.pluginId}:`, error);
          }
        }
      }
    });

    notification.show();
  }

  private async fetchLatestVersion(pluginId: string): Promise<any> {
    // 实现同 PluginInstaller
  }

  private compareVersions(v1: string, v2: string): number {
    // 实现同 PluginInstaller
  }
}
```

---

## 十一、插件设置界面

### 11.1 插件管理 UI

```typescript
// 插件管理界面（React 组件）

interface PluginListProps {
  plugins: PluginInfo[];
}

function PluginList({ plugins }: PluginListProps) {
  const [selectedPlugin, setSelectedPlugin] = useState<string | null>(null);

  const handleToggle = async (pluginId: string, enabled: boolean) => {
    if (enabled) {
      await window.electronAPI.plugin.enable(pluginId);
    } else {
      await window.electronAPI.plugin.disable(pluginId);
    }
  };

  const handleUninstall = async (pluginId: string) => {
    const confirmed = await window.electronAPI.ui.showDialog({
      type: "warning",
      title: "Uninstall Plugin",
      message: "Are you sure you want to uninstall this plugin?",
      buttons: ["Cancel", "Uninstall"],
    });

    if (confirmed.response === 1) {
      await window.electronAPI.plugin.uninstall(pluginId);
    }
  };

  return (
    <div className="plugin-list">
      <div className="header">
        <h2>Installed Plugins</h2>
        <button
          onClick={() => {
            /* 打开市场 */
          }}
        >
          Browse Marketplace
        </button>
      </div>

      {plugins.map((plugin) => (
        <div key={plugin.id} className="plugin-item">
          <div className="plugin-icon">
            <img src={plugin.icon} alt={plugin.name} />
          </div>

          <div className="plugin-info">
            <h3>{plugin.name}</h3>
            <p>{plugin.description}</p>
            <span className="version">v{plugin.version}</span>
            <span className="author">by {plugin.author.name}</span>
          </div>

          <div className="plugin-actions">
            <Toggle
              checked={plugin.enabled}
              onChange={(enabled) => handleToggle(plugin.id, enabled)}
            />

            <button onClick={() => setSelectedPlugin(plugin.id)}>
              Settings
            </button>

            <button
              onClick={() => handleUninstall(plugin.id)}
              className="danger"
            >
              Uninstall
            </button>
          </div>
        </div>
      ))}

      {selectedPlugin && (
        <PluginSettings
          pluginId={selectedPlugin}
          onClose={() => setSelectedPlugin(null)}
        />
      )}
    </div>
  );
}

// 插件设置对话框
function PluginSettings({ pluginId, onClose }: any) {
  const [permissions, setPermissions] = useState<string[]>([]);

  useEffect(() => {
    loadPermissions();
  }, [pluginId]);

  const loadPermissions = async () => {
    const perms = await window.electronAPI.plugin.getPermissions(pluginId);
    setPermissions(perms);
  };

  const handleRevokePermission = async (permission: string) => {
    await window.electronAPI.plugin.revokePermission(pluginId, permission);
    loadPermissions();
  };

  return (
    <div className="modal">
      <div className="modal-content">
        <h2>Plugin Settings</h2>

        <div className="section">
          <h3>Permissions</h3>
          <ul className="permission-list">
            {permissions.map((perm) => (
              <li key={perm}>
                <span>{perm}</span>
                <button onClick={() => handleRevokePermission(perm)}>
                  Revoke
                </button>
              </li>
            ))}
          </ul>
        </div>

        <div className="section">
          <h3>Data</h3>
          <button
            onClick={async () => {
              await window.electronAPI.plugin.clearData(pluginId);
            }}
          >
            Clear Plugin Data
          </button>
        </div>

        <button onClick={onClose}>Close</button>
      </div>
    </div>
  );
}
```

---

## 十二、最佳实践

### 12.1 插件开发最佳实践

#### ✅ DO（推荐做法）

1. **最小权限原则**

   - 只申请必需的权限
   - 在 manifest 中明确说明权限用途

2. **错误处理**

   - 使用 try-catch 捕获所有异步操作
   - 提供友好的错误提示
   - 记录详细的错误日志

3. **性能优化**

   - 避免在主循环中执行重操作
   - 使用防抖和节流
   - 及时释放资源

4. **用户体验**

   - 提供清晰的配置界面
   - 显示操作进度
   - 支持撤销操作

5. **文档完善**
   - 提供详细的 README
   - 包含使用示例
   - 说明权限需求

#### ❌ DON'T（避免做法）

1. **不要**在沙箱中尝试突破限制
2. **不要**收集未经用户同意的数据
3. **不要**进行高频的网络请求
4. **不要**阻塞主线程
5. **不要**修改全局状态
6. **不要**依赖外部服务的可用性

---

### 12.2 安全编码指南

```typescript
// ❌ 错误：直接执行用户输入
async function badExample(api: PluginAPI, userInput: string) {
  await api.tab.executeScript(tabId, userInput); // 危险！
}

// ✅ 正确：验证和清理输入
async function goodExample(api: PluginAPI, userInput: string) {
  // 1. 验证输入
  if (!isValidInput(userInput)) {
    throw new Error("Invalid input");
  }

  // 2. 使用参数化
  const safeCode = `
    (function(input) {
      // 使用传入的参数，而非直接拼接
      console.log('User input:', input);
    })(${JSON.stringify(userInput)});
  `;

  await api.tab.executeScript(tabId, safeCode);
}

// ❌ 错误：存储敏感信息
async function badStorage(api: PluginAPI, password: string) {
  await api.storage.set("password", password); // 明文存储！
}

// ✅ 正确：加密存储
async function goodStorage(api: PluginAPI, password: string) {
  const crypto = require("crypto");
  const encrypted = crypto
    .createCipher("aes-256-cbc", "secret-key")
    .update(password, "utf8", "hex");

  await api.storage.set("password_encrypted", encrypted);
}
```

---

## 十三、测试插件

### 13.1 单元测试

```typescript
// tests/index.test.ts

import { activate, deactivate } from "../src/index";

describe("My Plugin", () => {
  let mockAPI: any;

  beforeEach(() => {
    // 创建模拟 API
    mockAPI = {
      workspace: {
        getAll: jest.fn().mockResolvedValue([]),
        onActivated: jest.fn().mockReturnValue({ dispose: jest.fn() }),
      },
      ui: {
        showNotification: jest.fn(),
        registerCommand: jest.fn().mockReturnValue({ dispose: jest.fn() }),
      },
      storage: {
        get: jest.fn().mockResolvedValue(null),
        set: jest.fn().mockResolvedValue(undefined),
      },
    };
  });

  test("should activate successfully", async () => {
    const result = await activate(mockAPI);

    expect(result).toBeDefined();
    expect(result.deactivate).toBeInstanceOf(Function);
  });

  test("should register command", async () => {
    await activate(mockAPI);

    expect(mockAPI.ui.registerCommand).toHaveBeenCalledWith(
      "myPlugin.doSomething",
      expect.any(Function)
    );
  });

  test("should listen to workspace events", async () => {
    await activate(mockAPI);

    expect(mockAPI.workspace.onActivated).toHaveBeenCalled();
  });

  test("should clean up on deactivate", async () => {
    const result = await activate(mockAPI);
    const disposeMock = jest.fn();

    mockAPI.ui.registerCommand.mockReturnValue({ dispose: disposeMock });

    if (result.deactivate) {
      await result.deactivate();
    }

    // 验证资源已清理
    // ...
  });
});
```

---

### 13.2 集成测试

```typescript
// tests/integration.test.ts

import { PluginHost } from "../../main/plugin-host";
import path from "path";

describe("Plugin Integration", () => {
  let pluginHost: PluginHost;

  beforeEach(() => {
    pluginHost = new PluginHost();
  });

  afterEach(async () => {
    // 清理
    const plugins = pluginHost.getAllPlugins();
    for (const plugin of plugins) {
      await pluginHost.unload(plugin.id);
    }
  });

  test("should load plugin", async () => {
    const pluginPath = path.join(__dirname, "../fixtures/test-plugin");

    await pluginHost.load(pluginPath);

    const plugins = pluginHost.getAllPlugins();
    expect(plugins).toHaveLength(1);
    expect(plugins[0].name).toBe("Test Plugin");
  });

  test("should enforce permissions", async () => {
    const pluginPath = path.join(__dirname, "../fixtures/no-permission-plugin");

    await pluginHost.load(pluginPath);

    // 尝试调用未授权的 API
    await expect(async () => {
      // ... 调用需要权限的操作
    }).rejects.toThrow("Permission denied");
  });

  test("should isolate plugin storage", async () => {
    const plugin1Path = path.join(__dirname, "../fixtures/plugin1");
    const plugin2Path = path.join(__dirname, "../fixtures/plugin2");

    await pluginHost.load(plugin1Path);
    await pluginHost.load(plugin2Path);

    // Plugin 1 写入数据
    await plugin1.storage.set("key", "value1");

    // Plugin 2 不应该能读取 Plugin 1 的数据
    const value = await plugin2.storage.get("key");
    expect(value).toBeNull();
  });
});
```

---

## 十四、总结

### 14.1 插件系统优势

1. **安全性**：沙箱隔离 + 权限管理
2. **灵活性**：丰富的 API + 多种扩展点
3. **易用性**：简洁的开发接口 + 完善的文档
4. **可靠性**：插件错误不影响主应用
5. **生态**：开放的市场 + 社区贡献

### 14.2 开发路线图

**Phase 1（MVP）：**

- ✅ 基础插件加载和沙箱
- ✅ 核心 API（Workspace、Tab、UI、Storage）
- ✅ 权限管理
- ✅ 3-5 个官方示例插件

**Phase 2（Beta）：**

- ✅ 插件市场（Web 界面）
- ✅ 自动更新机制
- ✅ 更多 API（HTTP、Clipboard、FileSystem）
- ✅ 开发者工具（调试、热重载）

**Phase 3（1.0）：**

- ✅ 完善的插件市场
- ✅ 插件审核系统
- ✅ 性能监控和优化
- ✅ 企业级插件管理

### 14.3 关键指标

| 指标         | 目标        | 说明            |
| ------------ | ----------- | --------------- |
| 插件加载时间 | < 500ms     | 从加载到激活    |
| API 响应时间 | < 50ms      | 95% 的 API 调用 |
| 内存占用     | < 50MB/插件 | 平均每个插件    |
| 安全漏洞     | 0           | 严重安全问题    |
| 插件数量     | 50+         | 1.0 发布时      |
| 活跃开发者   | 100+        | 1 年内          |

---

**文档版本：** v1.0  
**最后更新：** 2024-11-20  
**文档性质：** 技术设计文档  
**相关文档：** 技术架构设计文档、安全策略文档
