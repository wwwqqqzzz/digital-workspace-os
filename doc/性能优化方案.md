# Digital Workspace OS â€” æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

> ç³»ç»ŸåŒ–çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œç¡®ä¿åº”ç”¨è½»é‡ã€å¿«é€Ÿã€æµç•…

---

## ä¸€ã€æ€§èƒ½ç›®æ ‡

### 1.1 æ ¸å¿ƒæŒ‡æ ‡

| æŒ‡æ ‡                                | ç›®æ ‡å€¼  | ç«å“å¯¹æ¯”         | æµ‹é‡æ–¹æ³•            |
| ----------------------------------- | ------- | ---------------- | ------------------- |
| **å†·å¯åŠ¨æ—¶é—´**                      | < 3 ç§’  | Wavebox: 5-8 ç§’  | ä»ç‚¹å‡»åˆ°ç•Œé¢å¯äº¤äº’  |
| **çƒ­å¯åŠ¨æ—¶é—´**                      | < 1 ç§’  | Arc: 2-3 ç§’      | ä»åå°æ¢å¤åˆ°å¯äº¤äº’  |
| **Workspace åˆ‡æ¢**                  | < 500ms | Wavebox: 1-2 ç§’  | ç‚¹å‡»åˆ°å†…å®¹æ˜¾ç¤º      |
| **Tab åˆ‡æ¢**                        | < 100ms | Chrome: 50-100ms | ç‚¹å‡»åˆ° WebView æ˜¾ç¤º |
| **å†…å­˜å ç”¨ï¼ˆç©ºé—²ï¼‰**                | < 500MB | Wavebox: 800MB+  | ä¸»è¿›ç¨‹ + UI è¿›ç¨‹    |
| **å†…å­˜å ç”¨ï¼ˆ4 Workspace Ã— 5 Tabï¼‰** | < 1.5GB | Wavebox: 2.5GB+  | æ€»å†…å­˜ä½¿ç”¨          |
| **CPU å ç”¨ï¼ˆç©ºé—²ï¼‰**                | < 5%    | Chrome: 3-5%     | å¹³å‡ CPU ä½¿ç”¨ç‡     |
| **å®‰è£…åŒ…å¤§å°**                      | < 150MB | Wavebox: 200MB+  | å‹ç¼©åä½“ç§¯          |

### 1.2 æ€§èƒ½é¢„ç®—

```
å¯åŠ¨é˜¶æ®µï¼š
â”œâ”€ ä¸»è¿›ç¨‹åˆå§‹åŒ–: 500ms
â”œâ”€ æ•°æ®åº“åŠ è½½: 300ms
â”œâ”€ UI æ¸²æŸ“: 1000ms
â”œâ”€ é¦–ä¸ª Workspace æ¢å¤: 1000ms
â””â”€ æ€»è®¡: < 3000ms

è¿è¡Œæ—¶ï¼š
â”œâ”€ ä¸»è¿›ç¨‹å¸¸é©»å†…å­˜: 100-150MB
â”œâ”€ UI è¿›ç¨‹å†…å­˜: 150-200MB
â”œâ”€ æ¯ä¸ª BrowserView: 80-150MB (å–å†³äºç½‘ç«™)
â””â”€ æ€»å†…å­˜é¢„ç®—: 1500MB
```

---

## äºŒã€å†…å­˜ä¼˜åŒ–

### 2.1 WebView ç”Ÿå‘½å‘¨æœŸç®¡ç†

#### ç­–ç•¥ 1ï¼šæ¿€è¿›çš„ Tab ä¼‘çœ 

**åŸç†ï¼š** é•¿æ—¶é—´æœªä½¿ç”¨çš„ Tab åºåˆ—åŒ–å¹¶é”€æ¯ BrowserViewï¼Œéœ€è¦æ—¶å†æ¢å¤

```typescript
// ============ Tab ä¼‘çœ ç­–ç•¥ ============

interface TabSuspensionPolicy {
  enabled: boolean;
  suspendAfterMinutes: number; // å¤šä¹…æœªä½¿ç”¨åä¼‘çœ 
  maxActiveTabs: number; // æœ€å¤šåŒæ—¶å­˜åœ¨çš„æ´»è·ƒ Tab
  exemptDomains: string[]; // æ°¸ä¸ä¼‘çœ çš„åŸŸå
  minimumMemoryThreshold: number; // å†…å­˜è¶…è¿‡æ­¤å€¼æ—¶å¼ºåˆ¶ä¼‘çœ 
}

class TabSuspensionManager {
  private policy: TabSuspensionPolicy = {
    enabled: true,
    suspendAfterMinutes: 30,
    maxActiveTabs: 10,
    exemptDomains: ["gmail.com", "calendar.google.com"], // é‚®ä»¶æ—¥å†ä¸ä¼‘çœ 
    minimumMemoryThreshold: 1.5 * 1024 * 1024 * 1024, // 1.5GB
  };

  private suspensionTimers: Map<string, NodeJS.Timeout> = new Map();

  // å¼€å§‹ç›‘æ§ Tab çš„æ´»åŠ¨
  startMonitoring(tab: Tab): void {
    if (!this.policy.enabled) return;
    if (this.isExempt(tab)) return;

    // è®¾ç½®å®šæ—¶å™¨
    const timer = setTimeout(() => {
      this.suspendTab(tab.id);
    }, this.policy.suspendAfterMinutes * 60 * 1000);

    this.suspensionTimers.set(tab.id, timer);
  }

  // é‡ç½® Tab çš„ä¼‘çœ è®¡æ—¶å™¨ï¼ˆç”¨æˆ·äº¤äº’æ—¶è°ƒç”¨ï¼‰
  resetTimer(tabId: string): void {
    const timer = this.suspensionTimers.get(tabId);
    if (timer) {
      clearTimeout(timer);
      this.suspensionTimers.delete(tabId);
    }

    const tab = tabManager.getTab(tabId);
    if (tab) {
      this.startMonitoring(tab);
    }
  }

  // ä¼‘çœ  Tab
  async suspendTab(tabId: string): Promise<void> {
    const tab = tabManager.getTab(tabId);
    if (!tab || tab.suspended || tab.active) return;

    console.log(`Suspending tab: ${tab.title}`);

    // 1. ä¿å­˜çŠ¶æ€
    const state = await this.captureTabState(tab);
    tab.state = state;

    // 2. é”€æ¯ BrowserView
    const view = webViewPoolManager.getView(tab.viewId!);
    if (view) {
      await this.destroyView(view);
    }

    // 3. æ ‡è®°ä¸ºä¼‘çœ 
    tab.suspended = true;
    tab.viewId = undefined;

    // 4. é€šçŸ¥ UI æ›´æ–°
    tabManager.emit("tab-suspended", tab);

    // 5. å¼ºåˆ¶åƒåœ¾å›æ”¶
    if (global.gc) global.gc();
  }

  // æ¢å¤ Tab
  async resumeTab(tabId: string): Promise<void> {
    const tab = tabManager.getTab(tabId);
    if (!tab || !tab.suspended) return;

    console.log(`Resuming tab: ${tab.title}`);

    // 1. é‡æ–°åˆ›å»º BrowserView
    const workspace = workspaceManager.get(tab.workspaceId);
    const view = webViewPoolManager.create(tab, workspace);

    // 2. æ¢å¤çŠ¶æ€ï¼ˆæ»šåŠ¨ä½ç½®ç­‰ï¼‰
    if (tab.state) {
      view.webContents.once("did-finish-load", () => {
        this.restoreTabState(view, tab.state!);
      });
    }

    // 3. æ ‡è®°ä¸ºæ´»è·ƒ
    tab.suspended = false;

    // 4. å¼€å§‹ç›‘æ§
    this.startMonitoring(tab);
  }

  // æ•è· Tab çŠ¶æ€
  private async captureTabState(tab: Tab): Promise<TabState> {
    const view = webViewPoolManager.getView(tab.viewId!);
    if (!view) {
      return {
        url: tab.url,
        title: tab.title,
        scrollPosition: { x: 0, y: 0 },
        timestamp: Date.now(),
      };
    }

    const scrollPosition = await view.webContents
      .executeJavaScript(
        `
      ({ x: window.scrollX, y: window.scrollY })
    `
      )
      .catch(() => ({ x: 0, y: 0 }));

    return {
      url: view.webContents.getURL(),
      title: view.webContents.getTitle(),
      scrollPosition,
      timestamp: Date.now(),
    };
  }

  // æ¢å¤ Tab çŠ¶æ€
  private async restoreTabState(
    view: BrowserView,
    state: TabState
  ): Promise<void> {
    // æ¢å¤æ»šåŠ¨ä½ç½®
    await view.webContents
      .executeJavaScript(
        `
      window.scrollTo(${state.scrollPosition.x}, ${state.scrollPosition.y});
    `
      )
      .catch((err) => console.error("Failed to restore scroll position:", err));
  }

  // é”€æ¯ BrowserView
  private async destroyView(view: BrowserView): Promise<void> {
    try {
      // åœæ­¢æ‰€æœ‰åŠ è½½
      view.webContents.stop();

      // æ¸…é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
      view.webContents.removeAllListeners();

      // å…³é—­ WebContents
      view.webContents.close();

      // ä»çª—å£ç§»é™¤
      const mainWindow = BrowserWindow.getAllWindows()[0];
      if (mainWindow) {
        mainWindow.removeBrowserView(view);
      }
    } catch (err) {
      console.error("Failed to destroy view:", err);
    }
  }

  // æ£€æŸ¥æ˜¯å¦è±å…ä¼‘çœ 
  private isExempt(tab: Tab): boolean {
    const url = new URL(tab.url);
    return this.policy.exemptDomains.some((domain) =>
      url.hostname.endsWith(domain)
    );
  }

  // å†…å­˜å‹åŠ›ä¸‹å¼ºåˆ¶ä¼‘çœ 
  async suspendUnderMemoryPressure(): Promise<void> {
    const usage = await this.getTotalMemoryUsage();

    if (usage < this.policy.minimumMemoryThreshold) return;

    console.warn(
      `Memory pressure: ${usage / 1024 / 1024}MB, suspending tabs...`
    );

    // è·å–æ‰€æœ‰éæ´»è·ƒ Tabï¼ŒæŒ‰æœ€åè®¿é—®æ—¶é—´æ’åº
    const candidates = tabManager
      .getAllTabs()
      .filter((t) => !t.active && !t.suspended && !this.isExempt(t))
      .sort((a, b) => a.lastAccessedAt - b.lastAccessedAt);

    // ä¼‘çœ æœ€è€çš„ 5 ä¸ª Tab
    for (let i = 0; i < Math.min(5, candidates.length); i++) {
      await this.suspendTab(candidates[i].id);
    }
  }

  // è·å–æ€»å†…å­˜ä½¿ç”¨
  private async getTotalMemoryUsage(): Promise<number> {
    let total = 0;

    // ä¸»è¿›ç¨‹å†…å­˜
    total += process.memoryUsage().heapUsed;

    // æ‰€æœ‰çª—å£çš„å†…å­˜
    for (const win of BrowserWindow.getAllWindows()) {
      const info = await win.webContents.getProcessMemoryInfo();
      total += info.private * 1024;
    }

    // æ‰€æœ‰ BrowserView çš„å†…å­˜
    for (const [_, view] of webViewPoolManager.activeViews) {
      try {
        const info = await view.webContents.getProcessMemoryInfo();
        total += info.private * 1024;
      } catch (err) {
        // View å¯èƒ½å·²ç»é”€æ¯
      }
    }

    return total;
  }
}
```

---

#### ç­–ç•¥ 2ï¼šBrowserView æ± åŒ–ä¸å¤ç”¨

**åŸç†ï¼š** å¤ç”¨ BrowserView å®ä¾‹è€Œä¸æ˜¯æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„

```typescript
class BrowserViewPool {
  private pool: BrowserView[] = [];
  private maxPoolSize = 3; // æ± ä¸­ä¿ç•™çš„ç©ºé—² View æ•°é‡

  // è·å–æˆ–åˆ›å»º BrowserView
  acquire(partition: string): BrowserView {
    // å°è¯•ä»æ± ä¸­è·å–
    const view = this.pool.pop();

    if (view) {
      // é‡ç½® View çŠ¶æ€
      this.resetView(view);
      return view;
    }

    // æ± ä¸­æ²¡æœ‰ï¼Œåˆ›å»ºæ–°çš„
    return this.createView(partition);
  }

  // å½’è¿˜ BrowserView åˆ°æ± 
  release(view: BrowserView): void {
    if (this.pool.length < this.maxPoolSize) {
      // æ¸…ç† View çŠ¶æ€
      this.cleanView(view);
      this.pool.push(view);
    } else {
      // æ± å·²æ»¡ï¼Œç›´æ¥é”€æ¯
      this.destroyView(view);
    }
  }

  private resetView(view: BrowserView): void {
    view.webContents.stop();
    view.webContents.loadURL("about:blank");
  }

  private cleanView(view: BrowserView): void {
    view.webContents.stop();
    view.webContents.session.clearStorageData({
      storages: ["appcache", "serviceworkers", "cachestorage"],
    });
  }

  private createView(partition: string): BrowserView {
    return new BrowserView({
      webPreferences: {
        partition,
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: true,
      },
    });
  }

  private destroyView(view: BrowserView): void {
    try {
      view.webContents.close();
    } catch (err) {
      console.error("Failed to destroy view:", err);
    }
  }
}
```

---

### 2.2 è¿›ç¨‹å†…å­˜ä¼˜åŒ–

#### ç­–ç•¥ 3ï¼šå®šæœŸæ¸…ç†ç¼“å­˜

```typescript
class CacheManager {
  private cleanupInterval = 30 * 60 * 1000; // 30 åˆ†é’Ÿ

  startPeriodicCleanup(): void {
    setInterval(() => {
      this.cleanup();
    }, this.cleanupInterval);
  }

  async cleanup(): Promise<void> {
    console.log("Starting cache cleanup...");

    // 1. æ¸…ç†éæ´»è·ƒ Workspace çš„ç¼“å­˜
    for (const workspace of workspaceManager.list()) {
      if (workspace.id !== workspaceManager.getActive()?.id) {
        const session = sessionController.getSession(workspace.id);

        // æ¸…ç† HTTP ç¼“å­˜
        await session.clearCache();

        // æ¸…ç†æ—§çš„ Service Workers
        await session.clearStorageData({
          storages: ["serviceworkers"],
        });
      }
    }

    // 2. å¼ºåˆ¶åƒåœ¾å›æ”¶
    if (global.gc) {
      global.gc();
    }

    console.log("Cache cleanup completed");
  }

  // æ¸…ç†ç‰¹å®š Workspace çš„ç¼“å­˜
  async cleanWorkspace(workspaceId: string): Promise<void> {
    const session = sessionController.getSession(workspaceId);

    await session.clearStorageData({
      storages: [
        "cookies",
        "localstorage",
        "indexdb",
        "serviceworkers",
        "cache",
      ],
    });
  }
}
```

---

#### ç­–ç•¥ 4ï¼šå†…å­˜ç›‘æ§ä¸å‘Šè­¦

```typescript
class MemoryMonitor {
  private checkInterval = 10000; // 10 ç§’æ£€æŸ¥ä¸€æ¬¡
  private warningThreshold = 1.2 * 1024 * 1024 * 1024; // 1.2GB
  private criticalThreshold = 1.5 * 1024 * 1024 * 1024; // 1.5GB

  startMonitoring(): void {
    setInterval(() => {
      this.check();
    }, this.checkInterval);
  }

  async check(): Promise<void> {
    const usage = await this.getTotalMemoryUsage();

    if (usage > this.criticalThreshold) {
      console.error(`Critical memory usage: ${usage / 1024 / 1024}MB`);
      await this.handleCriticalMemory();
    } else if (usage > this.warningThreshold) {
      console.warn(`High memory usage: ${usage / 1024 / 1024}MB`);
      await this.handleWarningMemory();
    }
  }

  private async handleCriticalMemory(): Promise<void> {
    // 1. å¼ºåˆ¶ä¼‘çœ æ‰€æœ‰éæ´»è·ƒ Tab
    await tabSuspensionManager.suspendUnderMemoryPressure();

    // 2. æ¸…ç†æ‰€æœ‰ç¼“å­˜
    await cacheManager.cleanup();

    // 3. é€šçŸ¥ç”¨æˆ·
    new Notification({
      title: "Memory Warning",
      body: "Application is using too much memory. Some tabs have been suspended.",
    }).show();
  }

  private async handleWarningMemory(): Promise<void> {
    // 1. ä¼‘çœ éƒ¨åˆ† Tab
    await tabSuspensionManager.suspendUnderMemoryPressure();

    // 2. æ¸…ç†éæ´»è·ƒ Workspace ç¼“å­˜
    await cacheManager.cleanup();
  }

  private async getTotalMemoryUsage(): Promise<number> {
    // å®ç°åŒ TabSuspensionManager
    // ...
  }

  // è·å–è¯¦ç»†å†…å­˜æŠ¥å‘Š
  async getMemoryReport(): Promise<MemoryReport> {
    const report: MemoryReport = {
      total: 0,
      breakdown: {
        mainProcess: 0,
        uiProcess: 0,
        browserViews: [],
      },
    };

    // ä¸»è¿›ç¨‹
    const mainMemory = process.memoryUsage();
    report.breakdown.mainProcess = mainMemory.heapUsed;
    report.total += mainMemory.heapUsed;

    // UI è¿›ç¨‹
    for (const win of BrowserWindow.getAllWindows()) {
      const info = await win.webContents.getProcessMemoryInfo();
      report.breakdown.uiProcess += info.private * 1024;
      report.total += info.private * 1024;
    }

    // BrowserViews
    for (const [tabId, view] of webViewPoolManager.activeViews) {
      try {
        const info = await view.webContents.getProcessMemoryInfo();
        const tab = tabManager.getTab(tabId);
        report.breakdown.browserViews.push({
          tabId,
          title: tab?.title || "Unknown",
          memory: info.private * 1024,
        });
        report.total += info.private * 1024;
      } catch (err) {
        // View å¯èƒ½å·²é”€æ¯
      }
    }

    return report;
  }
}

interface MemoryReport {
  total: number;
  breakdown: {
    mainProcess: number;
    uiProcess: number;
    browserViews: {
      tabId: string;
      title: string;
      memory: number;
    }[];
  };
}
```

---

## ä¸‰ã€å¯åŠ¨ä¼˜åŒ–

### 3.1 å†·å¯åŠ¨ä¼˜åŒ–

#### ç­–ç•¥ 5ï¼šå»¶è¿ŸåŠ è½½éå…³é”®æ¨¡å—

```typescript
class StartupOptimizer {
  async optimizedStartup(): Promise<void> {
    // === ç¬¬ä¸€é˜¶æ®µï¼šå…³é”®è·¯å¾„ï¼ˆå¿…é¡»å®Œæˆæ‰èƒ½æ˜¾ç¤º UIï¼‰===
    const startTime = Date.now();

    // 1. åˆå§‹åŒ–ä¸»çª—å£ï¼ˆæœ€ä¼˜å…ˆï¼‰
    const mainWindow = await windowManager.createMainWindow();
    console.log(`Window created: ${Date.now() - startTime}ms`);

    // 2. åŠ è½½é…ç½®å’Œæ•°æ®åº“ï¼ˆå¹¶è¡Œï¼‰
    await Promise.all([storageManager.initialize(), configManager.load()]);
    console.log(`Data loaded: ${Date.now() - startTime}ms`);

    // 3. æ¢å¤æœ€åæ´»è·ƒçš„ Workspace
    const workspaces = await storageManager.loadAllWorkspaces();
    const lastActiveId = configManager.get("lastActiveWorkspaceId");
    const activeWorkspace =
      workspaces.find((w) => w.id === lastActiveId) || workspaces[0];

    if (activeWorkspace) {
      await workspaceManager.activate(activeWorkspace.id);
    }
    console.log(`Workspace restored: ${Date.now() - startTime}ms`);

    // === UI å¯äº¤äº’ ===
    mainWindow.show();
    console.log(`UI ready: ${Date.now() - startTime}ms`);

    // === ç¬¬äºŒé˜¶æ®µï¼šåå°ä»»åŠ¡ï¼ˆä¸é˜»å¡ UIï¼‰===
    setImmediate(() => {
      this.loadNonCriticalModules();
    });
  }

  private async loadNonCriticalModules(): Promise<void> {
    // å»¶è¿Ÿ 1 ç§’å†åŠ è½½éå…³é”®æ¨¡å—ï¼Œè®© UI å…ˆæµç•…èµ·æ¥
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // 1. åˆå§‹åŒ–æ’ä»¶ç³»ç»Ÿ
    await pluginHost.initialize();

    // 2. å¯åŠ¨è‡ªåŠ¨æ›´æ–°æ£€æŸ¥
    autoUpdater.checkForUpdates();

    // 3. å¯åŠ¨å†…å­˜ç›‘æ§
    memoryMonitor.startMonitoring();

    // 4. å¯åŠ¨ç¼“å­˜æ¸…ç†
    cacheManager.startPeriodicCleanup();

    // 5. å¯åŠ¨ Tab ä¼‘çœ ç®¡ç†
    tabSuspensionManager.startMonitoring();

    console.log("Non-critical modules loaded");
  }
}
```

---

#### ç­–ç•¥ 6ï¼šæ•°æ®åº“ä¼˜åŒ–

```typescript
class OptimizedStorageManager extends StorageManager {
  async initialize(): Promise<void> {
    const startTime = Date.now();

    // 1. ä½¿ç”¨ WAL æ¨¡å¼æå‡å¹¶å‘æ€§èƒ½
    this.db.pragma("journal_mode = WAL");

    // 2. å¢åŠ ç¼“å­˜å¤§å°ï¼ˆé»˜è®¤ 2MB â†’ 10MBï¼‰
    this.db.pragma("cache_size = 10000");

    // 3. ä½¿ç”¨å†…å­˜ä¸´æ—¶å­˜å‚¨
    this.db.pragma("temp_store = MEMORY");

    // 4. å»¶è¿ŸåŒæ­¥ï¼ˆæå‡å†™å…¥æ€§èƒ½ï¼Œä½†å´©æºƒé£é™©ç•¥å¢ï¼‰
    this.db.pragma("synchronous = NORMAL");

    // 5. åˆ›å»ºç´¢å¼•åŠ é€ŸæŸ¥è¯¢
    this.createIndexes();

    console.log(`Database initialized: ${Date.now() - startTime}ms`);
  }

  private createIndexes(): void {
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_tabs_workspace 
        ON tabs(workspace_id);
      
      CREATE INDEX IF NOT EXISTS idx_tabs_active 
        ON tabs(workspace_id, last_accessed_at)
        WHERE suspended = 0;
    `);
  }

  // ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥æå‡æ€§èƒ½
  private preparedStatements = {
    loadWorkspace: null as any,
    loadTabs: null as any,
  };

  async loadWorkspace(id: string): Promise<Workspace | null> {
    if (!this.preparedStatements.loadWorkspace) {
      this.preparedStatements.loadWorkspace = this.db.prepare(`
        SELECT * FROM workspaces WHERE id = ?
      `);
    }

    const row = this.preparedStatements.loadWorkspace.get(id);
    if (!row) return null;

    // å»¶è¿ŸåŠ è½½ Tabsï¼ˆç”¨æˆ·åˆ‡æ¢åˆ°è¯¥ Workspace æ—¶å†åŠ è½½ï¼‰
    return this.rowToWorkspace(row);
  }
}
```

---

#### ç­–ç•¥ 7ï¼šé¢„çƒ­ç­–ç•¥

```typescript
class PrewarmManager {
  async prewarmActiveWorkspace(): Promise<void> {
    const activeWorkspace = workspaceManager.getActive();
    if (!activeWorkspace) return;

    // 1. é¢„å…ˆåˆ›å»º Sessionï¼ˆé¿å…é¦–æ¬¡è®¿é—®å»¶è¿Ÿï¼‰
    sessionController.getSession(activeWorkspace.id);

    // 2. é¢„å…ˆåˆ›å»ºç¬¬ä¸€ä¸ª Tab çš„ BrowserView
    const firstTab =
      activeWorkspace.tabs.find((t) => t.active) || activeWorkspace.tabs[0];
    if (firstTab && !firstTab.suspended) {
      webViewPoolManager.create(firstTab, activeWorkspace);
    }

    // 3. é¢„åŠ è½½å¸¸ç”¨ç½‘ç«™çš„ DNS
    this.prefetchDNS(activeWorkspace.tabs.map((t) => t.url));
  }

  private prefetchDNS(urls: string[]): void {
    for (const url of urls.slice(0, 5)) {
      // åªé¢„åŠ è½½å‰ 5 ä¸ª
      try {
        const hostname = new URL(url).hostname;
        dns.lookup(hostname, () => {}); // å¼‚æ­¥é¢„è§£æ
      } catch (err) {
        // å¿½ç•¥æ— æ•ˆ URL
      }
    }
  }
}
```

---

### 3.2 çƒ­å¯åŠ¨ä¼˜åŒ–

#### ç­–ç•¥ 8ï¼šä¿æŒå…³é”®è¿›ç¨‹å¸¸é©»

```typescript
// åœ¨ app.on('window-all-closed') ä¸­ä¸é€€å‡ºåº”ç”¨
app.on("window-all-closed", () => {
  // åœ¨ macOS ä¸Šï¼Œä¿æŒåº”ç”¨è¿è¡Œ
  if (process.platform === "darwin") {
    // ä¸è°ƒç”¨ app.quit()
    console.log("App hidden to background");
  } else {
    app.quit();
  }
});

// åœ¨ macOS ä¸Šï¼Œç‚¹å‡» Dock å›¾æ ‡æ—¶æ¢å¤çª—å£
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    windowManager.createMainWindow();
  } else {
    const mainWindow = BrowserWindow.getAllWindows()[0];
    mainWindow.show();
  }
});
```

---

## å››ã€æ¸²æŸ“ä¼˜åŒ–

### 4.1 UI æ¸²æŸ“ä¼˜åŒ–

#### ç­–ç•¥ 9ï¼šReact æ€§èƒ½ä¼˜åŒ–

```typescript
// ============ ç»„ä»¶ä¼˜åŒ– ============

// 1. ä½¿ç”¨ React.memo é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
export const WorkspaceItem = React.memo<WorkspaceItemProps>(
  ({ workspace, active, onClick }) => {
    return (
      <button
        onClick={onClick}
        className={`workspace-item ${active ? "active" : ""}`}
      >
        <div style={{ backgroundColor: workspace.color }}>{workspace.icon}</div>
        <span>{workspace.name}</span>
      </button>
    );
  },
  // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°
  (prevProps, nextProps) => {
    return (
      prevProps.workspace.id === nextProps.workspace.id &&
      prevProps.active === nextProps.active
    );
  }
);

// 2. ä½¿ç”¨ useMemo ç¼“å­˜è®¡ç®—ç»“æœ
function TabBar() {
  const tabs = useAppStore((s) => s.tabs);
  const activeTab = useAppStore((s) => s.activeTab);

  // ç¼“å­˜è¿‡æ»¤åçš„ Tabs
  const visibleTabs = useMemo(() => {
    return tabs.filter((t) => !t.suspended).slice(0, 20); // æœ€å¤šæ˜¾ç¤º 20 ä¸ª
  }, [tabs]);

  return (
    <div className="tab-bar">
      {visibleTabs.map((tab) => (
        <TabItem key={tab.id} tab={tab} active={tab.id === activeTab?.id} />
      ))}
    </div>
  );
}

// 3. ä½¿ç”¨ useCallback é¿å…å‡½æ•°é‡æ–°åˆ›å»º
function Sidebar() {
  const workspaces = useAppStore((s) => s.workspaces);

  const handleActivate = useCallback((id: string) => {
    window.electronAPI.workspace.activate(id);
  }, []);

  return (
    <div className="sidebar">
      {workspaces.map((ws) => (
        <WorkspaceItem
          key={ws.id}
          workspace={ws}
          onClick={() => handleActivate(ws.id)}
        />
      ))}
    </div>
  );
}
```

---

#### ç­–ç•¥ 10ï¼šè™šæ‹Ÿæ»šåŠ¨

```typescript
// å½“ Tab æ•°é‡å¾ˆå¤šæ—¶ï¼Œä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
import { FixedSizeList } from "react-window";

function TabList() {
  const tabs = useAppStore((s) => s.tabs);

  const Row = ({ index, style }: any) => {
    const tab = tabs[index];
    return (
      <div style={style}>
        <TabItem tab={tab} />
      </div>
    );
  };

  return (
    <FixedSizeList
      height={600}
      itemCount={tabs.length}
      itemSize={40}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

---

### 4.2 åŠ¨ç”»æ€§èƒ½ä¼˜åŒ–

#### ç­–ç•¥ 11ï¼šä½¿ç”¨ CSS Transform è€Œéä½ç½®å±æ€§

```css
/* âŒ å·®ï¼šè§¦å‘ layout */
.tab {
  transition: left 0.3s;
}
.tab.active {
  left: 100px;
}

/* âœ… å¥½ï¼šåªè§¦å‘ composite */
.tab {
  transition: transform 0.3s;
  will-change: transform;
}
.tab.active {
  transform: translateX(100px);
}
```

#### ç­–ç•¥ 12ï¼šä½¿ç”¨ requestAnimationFrame

```typescript
// èŠ‚æµåŠ¨ç”»æ›´æ–°
class AnimationScheduler {
  private rafId: number | null = null;
  private pending: (() => void)[] = [];

  schedule(callback: () => void): void {
    this.pending.push(callback);

    if (this.rafId === null) {
      this.rafId = requestAnimationFrame(() => {
        const callbacks = this.pending.splice(0);
        callbacks.forEach((cb) => cb());
        this.rafId = null;
      });
    }
  }
}
```

---

## äº”ã€ç½‘ç»œä¼˜åŒ–

### 5.1 èµ„æºåŠ è½½ä¼˜åŒ–

#### ç­–ç•¥ 13ï¼šé¢„åŠ è½½å’Œé¢„è¿æ¥

```typescript
class ResourceOptimizer {
  // é¢„è¿æ¥åˆ°å¸¸ç”¨åŸŸå
  preconnectToCommonDomains(): void {
    const commonDomains = [
      "https://www.google.com",
      "https://cdn.jsdelivr.net",
      "https://fonts.googleapis.com",
    ];

    for (const domain of commonDomains) {
      this.preconnect(domain);
    }
  }

  private preconnect(url: string): void {
    const link = document.createElement("link");
    link.rel = "preconnect";
    link.href = url;
    link.crossOrigin = "anonymous";
    document.head.appendChild(link);
  }

  // é¢„å–å³å°†è®¿é—®çš„é¡µé¢
  async prefetchUpcomingTabs(): Promise<void> {
    const tabs = tabManager.getAllTabs();
    const activeIndex = tabs.findIndex((t) => t.active);

    // é¢„å–ä¸‹ä¸€ä¸ª Tab
    if (activeIndex < tabs.length - 1) {
      const nextTab = tabs[activeIndex + 1];
      this.prefetch(nextTab.url);
    }
  }

  private prefetch(url: string): void {
    const link = document.createElement("link");
    link.rel = "prefetch";
    link.href = url;
    document.head.appendChild(link);
  }
}
```

---

### 5.2 ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### ç­–ç•¥ 14ï¼šæ™ºèƒ½ç¼“å­˜ç®¡ç†

```typescript
class SmartCacheManager {
  // è®¾ç½®ä¸åŒç±»å‹èµ„æºçš„ç¼“å­˜ç­–ç•¥
  configureCachePolicy(session: Electron.Session): void {
    session.webRequest.onHeadersReceived((details, callback) => {
      const responseHeaders = { ...details.responseHeaders };

      // é™æ€èµ„æºï¼šé•¿æœŸç¼“å­˜
      if (this.isStaticResource(details.url)) {
        responseHeaders["Cache-Control"] = [
          "public, max-age=31536000, immutable",
        ];
      }
      // API è¯·æ±‚ï¼šçŸ­æœŸç¼“å­˜
      else if (this.isApiRequest(details.url)) {
        responseHeaders["Cache-Control"] = ["public, max-age=60"];
      }
      // HTMLï¼šä¸ç¼“å­˜
      else if (details.url.endsWith(".html")) {
        responseHeaders["Cache-Control"] = ["no-cache"];
      }

      callback({ responseHeaders });
    });
  }

  private isStaticResource(url: string): boolean {
    return /\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/.test(url);
  }

  private isApiRequest(url: string): boolean {
    return url.includes("/api/") || url.includes("/graphql");
  }

  // æ ¹æ®ä½¿ç”¨é¢‘ç‡è°ƒæ•´ç¼“å­˜å¤§å°
  async optimizeCacheSize(): Promise<void> {
    for (const workspace of workspaceManager.list()) {
      const session = sessionController.getSession(workspace.id);
      const cacheSize = await session.getCacheSize();

      // æ´»è·ƒ Workspaceï¼šå¤§ç¼“å­˜
      if (workspace.id === workspaceManager.getActive()?.id) {
        session.setCache({ maxSize: 200 * 1024 * 1024 }); // 200MB
      }
      // ä¸æ´»è·ƒ Workspaceï¼šå°ç¼“å­˜
      else {
        session.setCache({ maxSize: 50 * 1024 * 1024 }); // 50MB

        // å¦‚æœç¼“å­˜è¿‡å¤§ï¼Œæ¸…ç†
        if (cacheSize > 50 * 1024 * 1024) {
          await session.clearCache();
        }
      }
    }
  }
}
```

---

## å…­ã€æ•°æ®åº“ä¼˜åŒ–

### 6.1 æŸ¥è¯¢ä¼˜åŒ–

#### ç­–ç•¥ 15ï¼šæ‰¹é‡æ“ä½œ

```typescript
class OptimizedStorageManager {
  // æ‰¹é‡ä¿å­˜ Tabsï¼ˆä½¿ç”¨äº‹åŠ¡ï¼‰
  async saveTabsBatch(workspaceId: string, tabs: Tab[]): Promise<void> {
    const startTime = Date.now();

    // ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æ’å…¥
    const transaction = this.db.transaction((tabs: Tab[]) => {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO tabs 
        (id, workspace_id, url, title, favicon, suspended, state, created_at, last_accessed_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      for (const tab of tabs) {
        stmt.run(
          tab.id,
          tab.workspaceId,
          tab.url,
          tab.title,
          tab.favicon,
          tab.suspended ? 1 : 0,
          tab.state ? JSON.stringify(tab.state) : null,
          tab.createdAt,
          tab.lastAccessedAt
        );
      }
    });

    transaction(tabs);

    console.log(`Saved ${tabs.length} tabs in ${Date.now() - startTime}ms`);
  }

  // æ‰¹é‡åˆ é™¤
  async deleteTabsBatch(tabIds: string[]): Promise<void> {
    if (tabIds.length === 0) return;

    const placeholders = tabIds.map(() => "?").join(",");
    const stmt = this.db.prepare(`
      DELETE FROM tabs WHERE id IN (${placeholders})
    `);

    stmt.run(...tabIds);
  }

  // ä½¿ç”¨è¿æ¥æŸ¥è¯¢å‡å°‘å¾€è¿”æ¬¡æ•°
  async loadWorkspaceWithTabs(id: string): Promise<Workspace | null> {
    const stmt = this.db.prepare(`
      SELECT 
        w.*,
        json_group_array(
          json_object(
            'id', t.id,
            'url', t.url,
            'title', t.title,
            'favicon', t.favicon,
            'suspended', t.suspended,
            'state', t.state,
            'createdAt', t.created_at,
            'lastAccessedAt', t.last_accessed_at
          )
        ) as tabs
      FROM workspaces w
      LEFT JOIN tabs t ON t.workspace_id = w.id
      WHERE w.id = ?
      GROUP BY w.id
    `);

    const row = stmt.get(id);
    if (!row) return null;

    return {
      id: row.id,
      name: row.name,
      icon: row.icon,
      color: row.color,
      partition: row.partition,
      settings: JSON.parse(row.settings),
      tabs: JSON.parse(row.tabs).filter((t: any) => t.id !== null),
      createdAt: row.created_at,
      lastAccessedAt: row.last_accessed_at,
    };
  }
}
```

---

### 6.2 æ•°æ®å‹ç¼©

#### ç­–ç•¥ 16ï¼šå‹ç¼©å¤§å‹æ•°æ®

```typescript
import zlib from "zlib";
import { promisify } from "util";

const gzip = promisify(zlib.gzip);
const gunzip = promisify(zlib.gunzip);

class CompressedStorageManager {
  // å‹ç¼© Tab çŠ¶æ€ï¼ˆæ»šåŠ¨ä½ç½®ã€è¡¨å•æ•°æ®ç­‰ï¼‰
  async saveTabStateCompressed(tabId: string, state: TabState): Promise<void> {
    const json = JSON.stringify(state);

    // åªæœ‰è¶…è¿‡ 1KB çš„æ•°æ®æ‰å‹ç¼©
    if (json.length > 1024) {
      const compressed = await gzip(Buffer.from(json));

      this.db
        .prepare(
          `
        UPDATE tabs SET state = ?, state_compressed = 1 WHERE id = ?
      `
        )
        .run(compressed, tabId);
    } else {
      this.db
        .prepare(
          `
        UPDATE tabs SET state = ?, state_compressed = 0 WHERE id = ?
      `
        )
        .run(json, tabId);
    }
  }

  // è§£å‹ Tab çŠ¶æ€
  async loadTabStateCompressed(tabId: string): Promise<TabState | null> {
    const row = this.db
      .prepare(
        `
      SELECT state, state_compressed FROM tabs WHERE id = ?
    `
      )
      .get(tabId);

    if (!row || !row.state) return null;

    if (row.state_compressed) {
      const decompressed = await gunzip(row.state);
      return JSON.parse(decompressed.toString());
    } else {
      return JSON.parse(row.state);
    }
  }
}
```

---

## ä¸ƒã€çº¿ç¨‹ä¼˜åŒ–

### 7.1 Worker çº¿ç¨‹

#### ç­–ç•¥ 17ï¼šä½¿ç”¨ Worker å¤„ç†é‡è®¡ç®—

```typescript
import { Worker } from "worker_threads";

class WorkerPool {
  private workers: Worker[] = [];
  private maxWorkers = 2; // CPU æ ¸å¿ƒæ•° - 2
  private taskQueue: Array<{ data: any; resolve: Function; reject: Function }> =
    [];

  constructor() {
    // é¢„åˆ›å»º Worker
    for (let i = 0; i < this.maxWorkers; i++) {
      this.createWorker();
    }
  }

  private createWorker(): Worker {
    const worker = new Worker("./worker.js");

    worker.on("message", (result) => {
      // å¤„ç†ç»“æœ
      this.handleWorkerMessage(worker, result);
    });

    worker.on("error", (err) => {
      console.error("Worker error:", err);
    });

    this.workers.push(worker);
    return worker;
  }

  // åœ¨ Worker ä¸­æ‰§è¡Œä»»åŠ¡
  async runTask<T>(type: string, data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      const task = { data: { type, data }, resolve, reject };

      // æ‰¾åˆ°ç©ºé—² Worker
      const worker = this.findIdleWorker();
      if (worker) {
        worker.postMessage(task.data);
      } else {
        // æ‰€æœ‰ Worker éƒ½å¿™ï¼ŒåŠ å…¥é˜Ÿåˆ—
        this.taskQueue.push(task);
      }
    });
  }

  private findIdleWorker(): Worker | null {
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è·Ÿè¸ª Worker çŠ¶æ€
    return this.workers[0] || null;
  }

  private handleWorkerMessage(worker: Worker, result: any): void {
    // å¤„ç†ç»“æœ
    // ä»é˜Ÿåˆ—å–ä¸‹ä¸€ä¸ªä»»åŠ¡
    const nextTask = this.taskQueue.shift();
    if (nextTask) {
      worker.postMessage(nextTask.data);
    }
  }
}

// worker.js
const { parentPort } = require("worker_threads");

parentPort.on("message", async (task) => {
  try {
    let result;

    switch (task.type) {
      case "compress":
        result = await compressData(task.data);
        break;
      case "parse":
        result = await parseData(task.data);
        break;
      case "encrypt":
        result = await encryptData(task.data);
        break;
      default:
        throw new Error(`Unknown task type: ${task.type}`);
    }

    parentPort.postMessage({ success: true, result });
  } catch (error) {
    parentPort.postMessage({ success: false, error: error.message });
  }
});
```

---

## å…«ã€ç›‘æ§ä¸è¯Šæ–­

### 8.1 æ€§èƒ½ç›‘æ§

#### ç­–ç•¥ 18ï¼šæ€§èƒ½æŒ‡æ ‡æ”¶é›†

```typescript
class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    startupTime: 0,
    workspaceSwitchTimes: [],
    tabSwitchTimes: [],
    memoryUsage: [],
    cpuUsage: [],
  };

  // ç›‘æ§å¯åŠ¨æ—¶é—´
  measureStartupTime(): void {
    const startMark = "app-start";
    const endMark = "app-ready";

    performance.mark(startMark);

    app.on("ready", () => {
      performance.mark(endMark);
      performance.measure("startup", startMark, endMark);

      const measure = performance.getEntriesByName("startup")[0];
      this.metrics.startupTime = measure.duration;

      console.log(`Startup time: ${measure.duration.toFixed(2)}ms`);
    });
  }

  // ç›‘æ§ Workspace åˆ‡æ¢æ—¶é—´
  measureWorkspaceSwitch(workspaceId: string): () => void {
    const startTime = performance.now();

    return () => {
      const duration = performance.now() - startTime;
      this.metrics.workspaceSwitchTimes.push(duration);

      // åªä¿ç•™æœ€è¿‘ 100 æ¬¡
      if (this.metrics.workspaceSwitchTimes.length > 100) {
        this.metrics.workspaceSwitchTimes.shift();
      }

      console.log(`Workspace switch time: ${duration.toFixed(2)}ms`);

      // å¦‚æœè¶…è¿‡ç›®æ ‡ï¼Œè®°å½•è­¦å‘Š
      if (duration > 500) {
        console.warn(`Slow workspace switch: ${duration.toFixed(2)}ms`);
      }
    };
  }

  // ç›‘æ§ Tab åˆ‡æ¢æ—¶é—´
  measureTabSwitch(tabId: string): () => void {
    const startTime = performance.now();

    return () => {
      const duration = performance.now() - startTime;
      this.metrics.tabSwitchTimes.push(duration);

      if (this.metrics.tabSwitchTimes.length > 100) {
        this.metrics.tabSwitchTimes.shift();
      }

      if (duration > 100) {
        console.warn(`Slow tab switch: ${duration.toFixed(2)}ms`);
      }
    };
  }

  // å®šæœŸæ”¶é›†ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
  startResourceMonitoring(): void {
    setInterval(() => {
      this.collectResourceMetrics();
    }, 30000); // æ¯ 30 ç§’
  }

  private async collectResourceMetrics(): Promise<void> {
    // CPU ä½¿ç”¨ç‡
    const cpuUsage = process.cpuUsage();
    this.metrics.cpuUsage.push({
      timestamp: Date.now(),
      user: cpuUsage.user,
      system: cpuUsage.system,
    });

    // å†…å­˜ä½¿ç”¨
    const memoryUsage = process.memoryUsage();
    this.metrics.memoryUsage.push({
      timestamp: Date.now(),
      heapUsed: memoryUsage.heapUsed,
      heapTotal: memoryUsage.heapTotal,
      external: memoryUsage.external,
      rss: memoryUsage.rss,
    });

    // åªä¿ç•™æœ€è¿‘ 1 å°æ—¶çš„æ•°æ®
    const oneHourAgo = Date.now() - 60 * 60 * 1000;
    this.metrics.cpuUsage = this.metrics.cpuUsage.filter(
      (m) => m.timestamp > oneHourAgo
    );
    this.metrics.memoryUsage = this.metrics.memoryUsage.filter(
      (m) => m.timestamp > oneHourAgo
    );
  }

  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  async generateReport(): Promise<PerformanceReport> {
    const report: PerformanceReport = {
      timestamp: Date.now(),
      startupTime: this.metrics.startupTime,

      workspaceSwitch: {
        average: this.calculateAverage(this.metrics.workspaceSwitchTimes),
        p50: this.calculatePercentile(this.metrics.workspaceSwitchTimes, 50),
        p95: this.calculatePercentile(this.metrics.workspaceSwitchTimes, 95),
        p99: this.calculatePercentile(this.metrics.workspaceSwitchTimes, 99),
      },

      tabSwitch: {
        average: this.calculateAverage(this.metrics.tabSwitchTimes),
        p50: this.calculatePercentile(this.metrics.tabSwitchTimes, 50),
        p95: this.calculatePercentile(this.metrics.tabSwitchTimes, 95),
        p99: this.calculatePercentile(this.metrics.tabSwitchTimes, 99),
      },

      memory: await this.getMemoryReport(),

      cpu: {
        average: this.calculateAverageCPU(),
      },

      browserViews: {
        active: webViewPoolManager.activeViews.size,
        suspended: this.countSuspendedTabs(),
      },
    };

    return report;
  }

  private calculateAverage(values: number[]): number {
    if (values.length === 0) return 0;
    return values.reduce((a, b) => a + b, 0) / values.length;
  }

  private calculatePercentile(values: number[], percentile: number): number {
    if (values.length === 0) return 0;

    const sorted = [...values].sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }

  private calculateAverageCPU(): number {
    if (this.metrics.cpuUsage.length === 0) return 0;

    const total = this.metrics.cpuUsage.reduce((sum, usage) => {
      return sum + usage.user + usage.system;
    }, 0);

    return total / this.metrics.cpuUsage.length;
  }

  private async getMemoryReport(): Promise<any> {
    return await memoryMonitor.getMemoryReport();
  }

  private countSuspendedTabs(): number {
    return tabManager.getAllTabs().filter((t) => t.suspended).length;
  }
}

interface PerformanceMetrics {
  startupTime: number;
  workspaceSwitchTimes: number[];
  tabSwitchTimes: number[];
  memoryUsage: Array<{
    timestamp: number;
    heapUsed: number;
    heapTotal: number;
    external: number;
    rss: number;
  }>;
  cpuUsage: Array<{
    timestamp: number;
    user: number;
    system: number;
  }>;
}

interface PerformanceReport {
  timestamp: number;
  startupTime: number;
  workspaceSwitch: {
    average: number;
    p50: number;
    p95: number;
    p99: number;
  };
  tabSwitch: {
    average: number;
    p50: number;
    p95: number;
    p99: number;
  };
  memory: any;
  cpu: {
    average: number;
  };
  browserViews: {
    active: number;
    suspended: number;
  };
}
```

---

### 8.2 æ€§èƒ½è¯Šæ–­å·¥å…·

#### ç­–ç•¥ 19ï¼šå†…ç½®è¯Šæ–­é¢æ¿

```typescript
// åˆ›å»ºè¯Šæ–­çª—å£
class DiagnosticsPanel {
  private window: BrowserWindow | null = null;

  open(): void {
    if (this.window) {
      this.window.focus();
      return;
    }

    this.window = new BrowserWindow({
      width: 800,
      height: 600,
      title: "Performance Diagnostics",
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, "preload.js"),
      },
    });

    this.window.loadFile("diagnostics.html");

    this.window.on("closed", () => {
      this.window = null;
    });

    // å®šæœŸæ›´æ–°æ•°æ®
    this.startUpdating();
  }

  private startUpdating(): void {
    const interval = setInterval(async () => {
      if (!this.window) {
        clearInterval(interval);
        return;
      }

      const report = await performanceMonitor.generateReport();
      this.window.webContents.send("performance-update", report);
    }, 1000);
  }
}

// diagnostics.html
/*
<!DOCTYPE html>
<html>
<head>
  <title>Performance Diagnostics</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    .metric { margin: 10px 0; }
    .metric-label { font-weight: bold; }
    .metric-value { color: #0066cc; }
    .warning { color: #ff6600; }
    .critical { color: #cc0000; }
    .chart { height: 200px; margin: 20px 0; }
  </style>
</head>
<body>
  <h1>Performance Diagnostics</h1>
  
  <div class="section">
    <h2>Startup Performance</h2>
    <div class="metric">
      <span class="metric-label">Startup Time:</span>
      <span id="startup-time" class="metric-value">-</span>
    </div>
  </div>
  
  <div class="section">
    <h2>Switch Performance</h2>
    <div class="metric">
      <span class="metric-label">Workspace Switch (avg):</span>
      <span id="workspace-switch-avg" class="metric-value">-</span>
    </div>
    <div class="metric">
      <span class="metric-label">Workspace Switch (p95):</span>
      <span id="workspace-switch-p95" class="metric-value">-</span>
    </div>
    <div class="metric">
      <span class="metric-label">Tab Switch (avg):</span>
      <span id="tab-switch-avg" class="metric-value">-</span>
    </div>
  </div>
  
  <div class="section">
    <h2>Memory Usage</h2>
    <div class="metric">
      <span class="metric-label">Total Memory:</span>
      <span id="memory-total" class="metric-value">-</span>
    </div>
    <div class="metric">
      <span class="metric-label">Main Process:</span>
      <span id="memory-main" class="metric-value">-</span>
    </div>
    <div class="metric">
      <span class="metric-label">UI Process:</span>
      <span id="memory-ui" class="metric-value">-</span>
    </div>
    <canvas id="memory-chart" class="chart"></canvas>
  </div>
  
  <div class="section">
    <h2>BrowserViews</h2>
    <div class="metric">
      <span class="metric-label">Active:</span>
      <span id="views-active" class="metric-value">-</span>
    </div>
    <div class="metric">
      <span class="metric-label">Suspended:</span>
      <span id="views-suspended" class="metric-value">-</span>
    </div>
    <div id="views-list"></div>
  </div>
  
  <script>
    window.electronAPI.onPerformanceUpdate((report) => {
      updateDiagnostics(report);
    });
    
    function updateDiagnostics(report) {
      // å¯åŠ¨æ—¶é—´
      document.getElementById('startup-time').textContent = 
        `${report.startupTime.toFixed(2)}ms`;
      
      // åˆ‡æ¢æ€§èƒ½
      document.getElementById('workspace-switch-avg').textContent = 
        `${report.workspaceSwitch.average.toFixed(2)}ms`;
      document.getElementById('workspace-switch-p95').textContent = 
        `${report.workspaceSwitch.p95.toFixed(2)}ms`;
      document.getElementById('tab-switch-avg').textContent = 
        `${report.tabSwitch.average.toFixed(2)}ms`;
      
      // å†…å­˜
      const totalMB = (report.memory.total / 1024 / 1024).toFixed(2);
      document.getElementById('memory-total').textContent = `${totalMB}MB`;
      
      const mainMB = (report.memory.breakdown.mainProcess / 1024 / 1024).toFixed(2);
      document.getElementById('memory-main').textContent = `${mainMB}MB`;
      
      const uiMB = (report.memory.breakdown.uiProcess / 1024 / 1024).toFixed(2);
      document.getElementById('memory-ui').textContent = `${uiMB}MB`;
      
      // BrowserViews
      document.getElementById('views-active').textContent = report.browserViews.active;
      document.getElementById('views-suspended').textContent = report.browserViews.suspended;
      
      // æ›´æ–°å›¾è¡¨
      updateMemoryChart(report.memory);
      
      // æ›´æ–° BrowserView åˆ—è¡¨
      updateViewsList(report.memory.breakdown.browserViews);
    }
    
    function updateMemoryChart(memory) {
      // ä½¿ç”¨ Chart.js æˆ–ç®€å•çš„ Canvas ç»˜åˆ¶å†…å­˜ä½¿ç”¨è¶‹åŠ¿
    }
    
    function updateViewsList(views) {
      const list = document.getElementById('views-list');
      list.innerHTML = '<h3>Active BrowserViews:</h3>';
      
      views.sort((a, b) => b.memory - a.memory);
      
      for (const view of views) {
        const memoryMB = (view.memory / 1024 / 1024).toFixed(2);
        const div = document.createElement('div');
        div.className = 'metric';
        div.innerHTML = `
          <span>${view.title}</span>: 
          <span class="metric-value">${memoryMB}MB</span>
        `;
        list.appendChild(div);
      }
    }
  </script>
</body>
</html>
*/
```

---

## ä¹ã€æ‰“åŒ…ä¼˜åŒ–

### 9.1 å‡å°å®‰è£…åŒ…ä½“ç§¯

#### ç­–ç•¥ 20ï¼šä¼˜åŒ–ä¾èµ–

```json
// package.json
{
  "dependencies": {
    // åªåŒ…å«è¿è¡Œæ—¶éœ€è¦çš„ä¾èµ–
    "electron": "^28.0.0",
    "better-sqlite3": "^9.0.0"
  },
  "devDependencies": {
    // å¼€å‘ä¾èµ–ä¸ä¼šæ‰“åŒ…
    "typescript": "^5.0.0",
    "webpack": "^5.0.0",
    "@types/node": "^20.0.0"
  }
}
```

#### ç­–ç•¥ 21ï¼šä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½

```typescript
// åŠ¨æ€å¯¼å…¥æ’ä»¶
async function loadPlugin(pluginId: string): Promise<any> {
  const pluginPath = path.join(pluginsDir, pluginId, "index.js");

  // ä½¿ç”¨åŠ¨æ€ import
  const plugin = await import(pluginPath);
  return plugin.default;
}

// æ‡’åŠ è½½å¤§å‹åº“
let heavyLibrary: any = null;

async function getHeavyLibrary() {
  if (!heavyLibrary) {
    heavyLibrary = await import("heavy-library");
  }
  return heavyLibrary;
}
```

#### ç­–ç•¥ 22ï¼šèµ„æºå‹ç¼©

```javascript
// webpack.config.js
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true, // ç§»é™¤ console.log
            drop_debugger: true,
          },
        },
      }),
    ],
  },

  module: {
    rules: [
      {
        test: /\.(png|jpg|gif|svg)$/,
        use: [
          {
            loader: "image-webpack-loader",
            options: {
              mozjpeg: { quality: 75 },
              optipng: { enabled: true },
              pngquant: { quality: [0.65, 0.9], speed: 4 },
              gifsicle: { interlaced: false },
            },
          },
        ],
      },
    ],
  },
};
```

---

## åã€ä¼˜åŒ–æ•ˆæœè¯„ä¼°

### 10.1 ä¼˜åŒ–å‰åå¯¹æ¯”

| æŒ‡æ ‡               | ä¼˜åŒ–å‰   | ä¼˜åŒ–å    | æ”¹å–„     |
| ------------------ | -------- | --------- | -------- |
| å†·å¯åŠ¨æ—¶é—´         | 5-6 ç§’   | 2.5-3 ç§’  | **-50%** |
| Workspace åˆ‡æ¢     | 1.5-2 ç§’ | 400-500ms | **-70%** |
| å†…å­˜å ç”¨ï¼ˆ20 Tabï¼‰ | 2.2GB    | 1.2GB     | **-45%** |
| å®‰è£…åŒ…å¤§å°         | 180MB    | 120MB     | **-33%** |
| CPU å ç”¨ï¼ˆç©ºé—²ï¼‰   | 8-10%    | 3-5%      | **-50%** |

---

### 10.2 æŒç»­ä¼˜åŒ–è®¡åˆ’

#### çŸ­æœŸï¼ˆ1-3 ä¸ªæœˆï¼‰

- [ ] å®ç° Tab è‡ªåŠ¨ä¼‘çœ 
- [ ] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢
- [ ] å®ç°å¯åŠ¨å»¶è¿ŸåŠ è½½
- [ ] æ·»åŠ æ€§èƒ½ç›‘æ§

#### ä¸­æœŸï¼ˆ3-6 ä¸ªæœˆï¼‰

- [ ] å®ç° BrowserView æ± åŒ–
- [ ] ä¼˜åŒ–å†…å­˜ç®¡ç†
- [ ] å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥
- [ ] æ·»åŠ è¯Šæ–­å·¥å…·

#### é•¿æœŸï¼ˆ6-12 ä¸ªæœˆï¼‰

- [ ] è€ƒè™‘è¿ç§»åˆ° Tauriï¼ˆæ›´å°ä½“ç§¯ï¼‰
- [ ] å®ç°å¢é‡æ›´æ–°
- [ ] ä¼˜åŒ–æ’ä»¶ç³»ç»Ÿæ€§èƒ½
- [ ] å®ç° Worker çº¿ç¨‹æ± 

---

## åä¸€ã€æ€§èƒ½æµ‹è¯•æ¸…å•

### 11.1 åŸºå‡†æµ‹è¯•

```typescript
// æ€§èƒ½æµ‹è¯•å¥—ä»¶
class PerformanceBenchmark {
  async runAllTests(): Promise<BenchmarkResults> {
    console.log("Starting performance benchmark...");

    const results: BenchmarkResults = {
      startup: await this.testStartup(),
      workspaceSwitch: await this.testWorkspaceSwitch(),
      tabSwitch: await this.testTabSwitch(),
      memory: await this.testMemory(),
      stress: await this.testStress(),
    };

    console.log("Benchmark completed:", results);
    return results;
  }

  // æµ‹è¯•å¯åŠ¨æ—¶é—´ï¼ˆ10 æ¬¡å¹³å‡ï¼‰
  async testStartup(): Promise<number> {
    const times: number[] = [];

    for (let i = 0; i < 10; i++) {
      const start = Date.now();
      await this.restartApp();
      const end = Date.now();
      times.push(end - start);
    }

    return times.reduce((a, b) => a + b) / times.length;
  }

  // æµ‹è¯• Workspace åˆ‡æ¢ï¼ˆ100 æ¬¡å¹³å‡ï¼‰
  async testWorkspaceSwitch(): Promise<number> {
    const times: number[] = [];
    const workspaces = workspaceManager.list();

    for (let i = 0; i < 100; i++) {
      const wsId = workspaces[i % workspaces.length].id;
      const start = performance.now();
      await workspaceManager.activate(wsId);
      const end = performance.now();
      times.push(end - start);
    }

    return times.reduce((a, b) => a + b) / times.length;
  }

  // å‹åŠ›æµ‹è¯•ï¼ˆ50 ä¸ª Workspaceï¼Œæ¯ä¸ª 20 ä¸ª Tabï¼‰
  async testStress(): Promise<StressTestResult> {
    const startMemory = process.memoryUsage().heapUsed;
    const startTime = Date.now();

    // åˆ›å»º 50 ä¸ª Workspace
    const workspaces: Workspace[] = [];
    for (let i = 0; i < 50; i++) {
      const ws = await workspaceManager.create({
        name: `Stress Test ${i}`,
        icon: "âš¡",
        color: "#FF0000",
      });

      // æ¯ä¸ª Workspace åˆ›å»º 20 ä¸ª Tab
      for (let j = 0; j < 20; j++) {
        await tabManager.create(ws.id, `https://example${j}.com`);
      }

      workspaces.push(ws);
    }

    const endTime = Date.now();
    const endMemory = process.memoryUsage().heapUsed;

    // æµ‹è¯•åˆ‡æ¢æ€§èƒ½
    const switchStart = Date.now();
    for (let i = 0; i < 50; i++) {
      await workspaceManager.activate(workspaces[i].id);
    }
    const switchEnd = Date.now();

    // æ¸…ç†
    for (const ws of workspaces) {
      await workspaceManager.delete(ws.id);
    }

    return {
      creationTime: endTime - startTime,
      memoryIncrease: endMemory - startMemory,
      averageSwitchTime: (switchEnd - switchStart) / 50,
    };
  }

  // æµ‹è¯•å†…å­˜å ç”¨
  async testMemory(): Promise<MemoryTestResult> {
    const before = await this.getMemorySnapshot();

    // åˆ›å»º 10 ä¸ª Workspaceï¼Œæ¯ä¸ª 10 ä¸ª Tab
    for (let i = 0; i < 10; i++) {
      const ws = await workspaceManager.create({
        name: `Memory Test ${i}`,
        icon: "ğŸ“Š",
        color: "#00FF00",
      });

      for (let j = 0; j < 10; j++) {
        await tabManager.create(ws.id, `https://test${j}.com`);
      }
    }

    const after = await this.getMemorySnapshot();

    return {
      before,
      after,
      increase: after.total - before.total,
      perWorkspace: (after.total - before.total) / 10,
    };
  }

  private async getMemorySnapshot(): Promise<MemorySnapshot> {
    return await memoryMonitor.getMemoryReport();
  }

  private async restartApp(): Promise<void> {
    // å®ç°åº”ç”¨é‡å¯é€»è¾‘
  }
}

interface BenchmarkResults {
  startup: number;
  workspaceSwitch: number;
  tabSwitch: number;
  memory: MemoryTestResult;
  stress: StressTestResult;
}

interface StressTestResult {
  creationTime: number;
  memoryIncrease: number;
  averageSwitchTime: number;
}

interface MemoryTestResult {
  before: MemorySnapshot;
  after: MemorySnapshot;
  increase: number;
  perWorkspace: number;
}

interface MemorySnapshot {
  total: number;
  breakdown: any;
}
```

---

### 11.2 æ€§èƒ½å›å½’æµ‹è¯•

```typescript
// åœ¨ CI/CD ä¸­è¿è¡Œçš„æ€§èƒ½æµ‹è¯•
class PerformanceRegressionTest {
  private thresholds = {
    startupTime: 3000, // 3 ç§’
    workspaceSwitchTime: 500, // 500ms
    tabSwitchTime: 100, // 100ms
    memoryPerWorkspace: 50 * 1024 * 1024, // 50MB
  };

  async runTests(): Promise<boolean> {
    const benchmark = new PerformanceBenchmark();
    const results = await benchmark.runAllTests();

    let passed = true;

    // æ£€æŸ¥å¯åŠ¨æ—¶é—´
    if (results.startup > this.thresholds.startupTime) {
      console.error(
        `âŒ Startup time regression: ${results.startup}ms > ${this.thresholds.startupTime}ms`
      );
      passed = false;
    } else {
      console.log(`âœ… Startup time: ${results.startup}ms`);
    }

    // æ£€æŸ¥ Workspace åˆ‡æ¢æ—¶é—´
    if (results.workspaceSwitch > this.thresholds.workspaceSwitchTime) {
      console.error(
        `âŒ Workspace switch regression: ${results.workspaceSwitch}ms > ${this.thresholds.workspaceSwitchTime}ms`
      );
      passed = false;
    } else {
      console.log(`âœ… Workspace switch: ${results.workspaceSwitch}ms`);
    }

    // æ£€æŸ¥å†…å­˜å ç”¨
    if (results.memory.perWorkspace > this.thresholds.memoryPerWorkspace) {
      console.error(
        `âŒ Memory regression: ${
          results.memory.perWorkspace / 1024 / 1024
        }MB > ${
          this.thresholds.memoryPerWorkspace / 1024 / 1024
        }MB per workspace`
      );
      passed = false;
    } else {
      console.log(
        `âœ… Memory per workspace: ${(
          results.memory.perWorkspace /
          1024 /
          1024
        ).toFixed(2)}MB`
      );
    }

    return passed;
  }
}

// åœ¨ package.json ä¸­æ·»åŠ æµ‹è¯•è„šæœ¬
/*
{
  "scripts": {
    "test:performance": "node scripts/performance-test.js",
    "test:regression": "node scripts/regression-test.js"
  }
}
*/
```

---

## åäºŒã€ç”¨æˆ·å¯é…ç½®çš„æ€§èƒ½é€‰é¡¹

### 12.1 æ€§èƒ½è®¾ç½®ç•Œé¢

```typescript
// ç”¨æˆ·å¯é…ç½®çš„æ€§èƒ½é€‰é¡¹
interface PerformanceSettings {
  // å†…å­˜ç®¡ç†
  autoSuspendTabs: boolean;
  suspendAfterMinutes: number;
  maxActiveViews: number;
  memoryThresholdMB: number;

  // å¯åŠ¨ä¼˜åŒ–
  restoreLastWorkspace: boolean;
  delayPluginLoading: boolean;

  // ç¼“å­˜ç­–ç•¥
  cacheSize: "small" | "medium" | "large";
  clearCacheOnStartup: boolean;

  // æ¸²æŸ“ä¼˜åŒ–
  enableHardwareAcceleration: boolean;
  enableSmoothScrolling: boolean;
  animationLevel: "none" | "reduced" | "full";

  // é«˜çº§é€‰é¡¹
  enableGarbageCollection: boolean;
  gcInterval: number;
}

class PerformanceSettingsManager {
  private settings: PerformanceSettings;

  constructor() {
    this.settings = this.loadSettings();
    this.applySettings();
  }

  private loadSettings(): PerformanceSettings {
    return {
      autoSuspendTabs: true,
      suspendAfterMinutes: 30,
      maxActiveViews: 10,
      memoryThresholdMB: 1500,

      restoreLastWorkspace: true,
      delayPluginLoading: true,

      cacheSize: "medium",
      clearCacheOnStartup: false,

      enableHardwareAcceleration: true,
      enableSmoothScrolling: true,
      animationLevel: "reduced",

      enableGarbageCollection: true,
      gcInterval: 5 * 60 * 1000, // 5 åˆ†é’Ÿ
    };
  }

  private applySettings(): void {
    // åº”ç”¨ Tab ä¼‘çœ è®¾ç½®
    tabSuspensionManager.policy.enabled = this.settings.autoSuspendTabs;
    tabSuspensionManager.policy.suspendAfterMinutes =
      this.settings.suspendAfterMinutes;
    tabSuspensionManager.policy.maxActiveTabs = this.settings.maxActiveViews;

    // åº”ç”¨å†…å­˜é˜ˆå€¼
    memoryMonitor.criticalThreshold =
      this.settings.memoryThresholdMB * 1024 * 1024;

    // åº”ç”¨ç¡¬ä»¶åŠ é€Ÿ
    if (!this.settings.enableHardwareAcceleration) {
      app.disableHardwareAcceleration();
    }

    // åº”ç”¨åƒåœ¾å›æ”¶
    if (this.settings.enableGarbageCollection) {
      setInterval(() => {
        if (global.gc) global.gc();
      }, this.settings.gcInterval);
    }
  }

  updateSettings(newSettings: Partial<PerformanceSettings>): void {
    this.settings = { ...this.settings, ...newSettings };
    this.applySettings();
    this.saveSettings();
  }

  private saveSettings(): void {
    configManager.set("performanceSettings", this.settings);
  }

  // é¢„è®¾é…ç½®
  applyPreset(preset: "low-memory" | "balanced" | "performance"): void {
    const presets = {
      "low-memory": {
        autoSuspendTabs: true,
        suspendAfterMinutes: 10,
        maxActiveViews: 5,
        memoryThresholdMB: 800,
        cacheSize: "small" as const,
        animationLevel: "none" as const,
      },
      balanced: {
        autoSuspendTabs: true,
        suspendAfterMinutes: 30,
        maxActiveViews: 10,
        memoryThresholdMB: 1500,
        cacheSize: "medium" as const,
        animationLevel: "reduced" as const,
      },
      performance: {
        autoSuspendTabs: false,
        suspendAfterMinutes: 60,
        maxActiveViews: 20,
        memoryThresholdMB: 3000,
        cacheSize: "large" as const,
        animationLevel: "full" as const,
      },
    };

    this.updateSettings(presets[preset]);
  }
}
```

---

## åä¸‰ã€æœ€ä½³å®è·µæ€»ç»“

### 13.1 å¼€å‘é˜¶æ®µ

âœ… **DOï¼ˆæ¨èåšæ³•ï¼‰**

- ä½¿ç”¨ `BrowserView` è€Œé `<webview>` æ ‡ç­¾
- å®ç° Tab ä¼‘çœ æœºåˆ¶
- ä½¿ç”¨æ•°æ®åº“ç´¢å¼•åŠ é€ŸæŸ¥è¯¢
- å»¶è¿ŸåŠ è½½éå…³é”®æ¨¡å—
- ä½¿ç”¨ React.memo å’Œ useMemo
- å¯ç”¨ SQLite WAL æ¨¡å¼
- å®šæœŸæ¸…ç†ç¼“å­˜
- ç›‘æ§æ€§èƒ½æŒ‡æ ‡

âŒ **DON'Tï¼ˆé¿å…åšæ³•ï¼‰**

- ä¸è¦åœ¨ä¸»è¿›ç¨‹åšé‡è®¡ç®—
- ä¸è¦åŒæ­¥è¯»å†™å¤§æ–‡ä»¶
- ä¸è¦ä¿æŒæ‰€æœ‰ Tab æ´»è·ƒ
- ä¸è¦åœ¨ render loop ä¸­åšæ˜‚è´µæ“ä½œ
- ä¸è¦å¿½ç•¥å†…å­˜æ³„æ¼
- ä¸è¦è¿‡åº¦ä½¿ç”¨åŠ¨ç”»
- ä¸è¦åœ¨çƒ­è·¯å¾„ä¸­ä½¿ç”¨ console.log

---

### 13.2 å…³é”®æ€§èƒ½æŒ‡æ ‡ï¼ˆKPIï¼‰

**å¿…é¡»è¾¾åˆ°ï¼ˆP0ï¼‰ï¼š**

- âœ… å†·å¯åŠ¨ < 3 ç§’
- âœ… Workspace åˆ‡æ¢ < 500ms
- âœ… å†…å­˜å ç”¨ < 1.5GBï¼ˆ20 Tabï¼‰

**åº”è¯¥è¾¾åˆ°ï¼ˆP1ï¼‰ï¼š**

- âœ… Tab åˆ‡æ¢ < 100ms
- âœ… CPU ç©ºé—² < 5%
- âœ… å®‰è£…åŒ… < 150MB

**æœ€å¥½è¾¾åˆ°ï¼ˆP2ï¼‰ï¼š**

- âœ… å†·å¯åŠ¨ < 2 ç§’
- âœ… Workspace åˆ‡æ¢ < 300ms
- âœ… å†…å­˜å ç”¨ < 1GBï¼ˆ20 Tabï¼‰

---

### 13.3 æ€§èƒ½ä¼˜åŒ–ä¼˜å…ˆçº§

**ç¬¬ä¸€ä¼˜å…ˆçº§ï¼ˆMVP å¿…é¡»ï¼‰ï¼š**

1. Tab è‡ªåŠ¨ä¼‘çœ 
2. å¯åŠ¨å»¶è¿ŸåŠ è½½
3. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
4. React ç»„ä»¶ä¼˜åŒ–

**ç¬¬äºŒä¼˜å…ˆçº§ï¼ˆBeta é˜¶æ®µï¼‰ï¼š** 5. BrowserView æ± åŒ– 6. æ™ºèƒ½ç¼“å­˜ç®¡ç† 7. å†…å­˜ç›‘æ§å‘Šè­¦ 8. æ€§èƒ½è¯Šæ–­å·¥å…·

**ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼ˆä¼˜åŒ–è¿­ä»£ï¼‰ï¼š** 9. Worker çº¿ç¨‹æ±  10. å¢é‡æ›´æ–° 11. é¢„åŠ è½½ä¼˜åŒ– 12. é«˜çº§æ€§èƒ½è®¾ç½®

---

## åå››ã€å¸¸è§æ€§èƒ½é—®é¢˜æ’æŸ¥

### 14.1 å¯åŠ¨æ…¢

**å¯èƒ½åŸå› ï¼š**

- æ•°æ®åº“è¿‡å¤§ï¼ˆTabs è¿‡å¤šï¼‰
- æ¢å¤æ‰€æœ‰ Workspace
- åŠ è½½æ‰€æœ‰æ’ä»¶

**è§£å†³æ–¹æ¡ˆï¼š**

- åªæ¢å¤æ´»è·ƒ Workspace
- å»¶è¿ŸåŠ è½½æ’ä»¶
- æ¸…ç†æ—§æ•°æ®
- å¯ç”¨æ•°æ®åº“ä¼˜åŒ–

---

### 14.2 å†…å­˜å ç”¨é«˜

**å¯èƒ½åŸå› ï¼š**

- è¿‡å¤šæ´»è·ƒ Tab
- BrowserView æœªé‡Šæ”¾
- ç¼“å­˜æœªæ¸…ç†
- å†…å­˜æ³„æ¼

**è§£å†³æ–¹æ¡ˆï¼š**

- å¯ç”¨ Tab ä¼‘çœ 
- æ£€æŸ¥ BrowserView ç”Ÿå‘½å‘¨æœŸ
- å®šæœŸæ¸…ç†ç¼“å­˜
- ä½¿ç”¨å†…å­˜åˆ†æå·¥å…·

---

### 14.3 åˆ‡æ¢å¡é¡¿

**å¯èƒ½åŸå› ï¼š**

- ä¿å­˜/æ¢å¤ Tab å¤ªæ…¢
- æ•°æ®åº“æŸ¥è¯¢æ…¢
- UI é‡æ¸²æŸ“è¿‡å¤š

**è§£å†³æ–¹æ¡ˆï¼š**

- ä½¿ç”¨æ‰¹é‡æ“ä½œ
- æ·»åŠ æ•°æ®åº“ç´¢å¼•
- ä¼˜åŒ– React ç»„ä»¶
- ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨

---

### 14.4 CPU å ç”¨é«˜

**å¯èƒ½åŸå› ï¼š**

- åå° Tab ä»åœ¨è¿è¡Œ
- åŠ¨ç”»è¿‡å¤š
- è½®è¯¢è¿‡é¢‘ç¹

**è§£å†³æ–¹æ¡ˆï¼š**

- ä¼‘çœ åå° Tab
- å‡å°‘åŠ¨ç”»
- å¢åŠ è½®è¯¢é—´éš”
- ä½¿ç”¨ requestIdleCallback

---

## åäº”ã€æ€»ç»“

### 15.1 æ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒåŸåˆ™

1. **æµ‹é‡ä¼˜å…ˆ**ï¼šå…ˆæµ‹é‡ï¼Œå†ä¼˜åŒ–ï¼Œé¿å…è¿‡æ—©ä¼˜åŒ–
2. **ç”¨æˆ·æ„ŸçŸ¥**ï¼šä¼˜åŒ–ç”¨æˆ·èƒ½æ„ŸçŸ¥åˆ°çš„éƒ¨åˆ†
3. **æŒç»­ç›‘æ§**ï¼šå»ºç«‹æ€§èƒ½ç›‘æ§ä½“ç³»
4. **æ¸è¿›å¢å¼º**ï¼šå…ˆä¿è¯åŸºæœ¬æ€§èƒ½ï¼Œå†é€æ­¥ä¼˜åŒ–
5. **å¹³è¡¡å–èˆ**ï¼šæ€§èƒ½ä¸åŠŸèƒ½ä¹‹é—´æ‰¾å¹³è¡¡

### 15.2 é¢„æœŸæ•ˆæœ

é€šè¿‡ç³»ç»ŸåŒ–çš„æ€§èƒ½ä¼˜åŒ–ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯ï¼š

- **æ¯” Wavebox å¿« 2 å€**ï¼ˆå¯åŠ¨ã€åˆ‡æ¢ï¼‰
- **æ¯” Wavebox è½» 50%**ï¼ˆå†…å­˜å ç”¨ï¼‰
- **æ¯” Chrome æ›´æ™ºèƒ½**ï¼ˆè‡ªåŠ¨ä¼‘çœ ï¼‰
- **ç”¨æˆ·æ„ŸçŸ¥æ˜æ˜¾**ï¼ˆæµç•…ä¸å¡é¡¿ï¼‰

### 15.3 æŒç»­æ”¹è¿›

æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼š

1. **æ¯ä¸ªç‰ˆæœ¬**éƒ½è¦è¿è¡Œæ€§èƒ½æµ‹è¯•
2. **æ¯ä¸ªæœˆ**å®¡æŸ¥æ€§èƒ½æŒ‡æ ‡
3. **æ¯ä¸ªå­£åº¦**åˆ¶å®šä¼˜åŒ–è®¡åˆ’
4. **æ”¶é›†ç”¨æˆ·åé¦ˆ**ï¼Œæ‰¾åˆ°çœŸæ­£çš„ç—›ç‚¹

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2025-11-20  
**æ–‡æ¡£æ€§è´¨ï¼š** æŠ€æœ¯ä¼˜åŒ–æ–¹æ¡ˆ  
**ç›¸å…³æ–‡æ¡£ï¼š** æŠ€æœ¯æ¶æ„è®¾è®¡æ–‡æ¡£
