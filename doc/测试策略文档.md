# Digital Workspace OS â€” æµ‹è¯•ç­–ç•¥æ–‡æ¡£

> å…¨é¢çš„æµ‹è¯•ç­–ç•¥ï¼Œç¡®ä¿è½¯ä»¶è´¨é‡ã€ç¨³å®šæ€§å’Œå¯é æ€§

---

## ä¸€ã€æµ‹è¯•ç›®æ ‡ä¸åŸåˆ™

### 1.1 æµ‹è¯•ç›®æ ‡

1. **åŠŸèƒ½æ­£ç¡®æ€§**ï¼šæ‰€æœ‰åŠŸèƒ½æŒ‰é¢„æœŸå·¥ä½œ
2. **ç¨³å®šæ€§**ï¼šé•¿æ—¶é—´è¿è¡Œä¸å´©æºƒ
3. **æ€§èƒ½è¾¾æ ‡**ï¼šæ»¡è¶³æ€§èƒ½æŒ‡æ ‡è¦æ±‚
4. **å®‰å…¨æ€§**ï¼šæ— å®‰å…¨æ¼æ´å’Œæ•°æ®æ³„éœ²
5. **è·¨å¹³å°å…¼å®¹**ï¼šWindows/Mac/Linux ä¸€è‡´ä½“éªŒ
6. **å›å½’é¢„é˜²**ï¼šé˜²æ­¢æ–°ä»£ç ç ´åç°æœ‰åŠŸèƒ½

### 1.2 æµ‹è¯•åŸåˆ™

```
é‡‘å­—å¡”åŸåˆ™ï¼š
        E2E (10%)
       /         \
      /           \
     /  Integration \
    /      (30%)     \
   /                  \
  /   Unit Tests (60%) \
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

åŸåˆ™ï¼š
- å•å…ƒæµ‹è¯•å æ¯”æœ€é«˜ï¼ˆå¿«é€Ÿã€éš”ç¦»ï¼‰
- é›†æˆæµ‹è¯•è¦†ç›–æ¨¡å—äº¤äº’
- E2E æµ‹è¯•è¦†ç›–å…³é”®ç”¨æˆ·æµç¨‹
- æµ‹è¯•è¶Šåº•å±‚è¶Šå¿«é€Ÿã€è¶Šç¨³å®š
```

### 1.3 è´¨é‡ç›®æ ‡

| æŒ‡æ ‡                | ç›®æ ‡å€¼      | æµ‹é‡æ–¹æ³•        |
| ------------------- | ----------- | --------------- |
| **ä»£ç è¦†ç›–ç‡**      | > 70%       | Jest coverage   |
| **å•å…ƒæµ‹è¯•é€šè¿‡ç‡**  | 100%        | CI/CD ç»“æœ      |
| **E2E æµ‹è¯•é€šè¿‡ç‡**  | > 95%       | Playwright ç»“æœ |
| **å…³é”®è·¯å¾„è¦†ç›–**    | 100%        | æ‰‹åŠ¨éªŒè¯        |
| **Bug å¯†åº¦**        | < 1 ä¸ª/KLOC | Bug è·Ÿè¸ªç³»ç»Ÿ    |
| **P0 Bug ä¿®å¤æ—¶é—´** | < 24 å°æ—¶   | Issue å“åº”æ—¶é—´  |
| **å›å½’ Bug ç‡**     | < 5%        | Release notes   |

---

## äºŒã€æµ‹è¯•åˆ†å±‚æ¶æ„

### 2.1 æµ‹è¯•å±‚çº§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         E2E Tests (ç«¯åˆ°ç«¯æµ‹è¯•)           â”‚
â”‚  - å®Œæ•´ç”¨æˆ·æµç¨‹                          â”‚
â”‚  - è·¨è¿›ç¨‹äº¤äº’                            â”‚
â”‚  - UI + Backend                         â”‚
â”‚  å·¥å…·ï¼šPlaywright / Spectron            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Integration Tests (é›†æˆæµ‹è¯•)         â”‚
â”‚  - æ¨¡å—é—´äº¤äº’                            â”‚
â”‚  - IPC é€šä¿¡                              â”‚
â”‚  - æ•°æ®åº“é›†æˆ                            â”‚
â”‚  å·¥å…·ï¼šJest + Test Doubles              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Unit Tests (å•å…ƒæµ‹è¯•)              â”‚
â”‚  - å•ä¸ªå‡½æ•°/ç±»                           â”‚
â”‚  - çº¯é€»è¾‘æµ‹è¯•                            â”‚
â”‚  - Mock å¤–éƒ¨ä¾èµ–                         â”‚
â”‚  å·¥å…·ï¼šJest + TypeScript                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¸‰ã€å•å…ƒæµ‹è¯•

### 3.1 å•å…ƒæµ‹è¯•ç­–ç•¥

#### æµ‹è¯•èŒƒå›´

**å¿…é¡»æµ‹è¯•ï¼š**

- âœ… æ‰€æœ‰ä¸šåŠ¡é€»è¾‘ç±»
- âœ… å·¥å…·å‡½æ•°å’Œè¾…åŠ©å‡½æ•°
- âœ… æ•°æ®æ¨¡å‹å’ŒéªŒè¯é€»è¾‘
- âœ… ç®—æ³•å®ç°
- âœ… é”™è¯¯å¤„ç†é€»è¾‘

**å¯é€‰æµ‹è¯•ï¼š**

- âš ï¸ ç®€å•çš„ getter/setter
- âš ï¸ UI ç»„ä»¶ï¼ˆå¦‚æœé€»è¾‘ç®€å•ï¼‰
- âš ï¸ ç¬¬ä¸‰æ–¹åº“åŒ…è£…å™¨

**ä¸éœ€è¦æµ‹è¯•ï¼š**

- âŒ ç¬¬ä¸‰æ–¹åº“æœ¬èº«
- âŒ çº¯ UI å±•ç¤ºç»„ä»¶ï¼ˆç”¨ E2E è¦†ç›–ï¼‰
- âŒ é…ç½®æ–‡ä»¶

---

### 3.2 æµ‹è¯•æ¡†æ¶é…ç½®

#### Jest é…ç½®

```javascript
// jest.config.js

module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",

  // æµ‹è¯•æ–‡ä»¶åŒ¹é…æ¨¡å¼
  testMatch: ["**/__tests__/**/*.test.ts", "**/?(*.)+(spec|test).ts"],

  // è¦†ç›–ç‡é…ç½®
  collectCoverageFrom: [
    "src/**/*.ts",
    "!src/**/*.d.ts",
    "!src/**/__tests__/**",
    "!src/main/index.ts", // å…¥å£æ–‡ä»¶
  ],

  coverageThresholds: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
    // æ ¸å¿ƒæ¨¡å—è¦æ±‚æ›´é«˜è¦†ç›–ç‡
    "./src/main/managers/": {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },

  // æ¨¡å—è·¯å¾„æ˜ å°„
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },

  // è®¾ç½®è¶…æ—¶æ—¶é—´
  testTimeout: 10000,

  // å¹¶è¡Œè¿è¡Œæµ‹è¯•
  maxWorkers: "50%",
};
```

#### TypeScript é…ç½®

```json
// tsconfig.test.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["jest", "node"]
  },
  "include": ["src/**/*.test.ts", "src/**/*.spec.ts"]
}
```

---

### 3.3 å•å…ƒæµ‹è¯•ç¤ºä¾‹

#### æµ‹è¯• Workspace Manager

```typescript
// src/main/managers/__tests__/WorkspaceManager.test.ts

import { WorkspaceManager } from "../WorkspaceManager";
import { StorageManager } from "../StorageManager";

// Mock ä¾èµ–
jest.mock("../StorageManager");

describe("WorkspaceManager", () => {
  let workspaceManager: WorkspaceManager;
  let mockStorageManager: jest.Mocked<StorageManager>;

  beforeEach(() => {
    // åˆ›å»º mock å®ä¾‹
    mockStorageManager = new StorageManager() as jest.Mocked<StorageManager>;
    workspaceManager = new WorkspaceManager(mockStorageManager);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("create", () => {
    it("should create a new workspace with valid config", async () => {
      const config = {
        name: "Test Workspace",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      };

      const workspace = await workspaceManager.create(config);

      expect(workspace).toMatchObject({
        name: config.name,
        icon: config.icon,
        color: config.color,
      });
      expect(workspace.id).toBeDefined();
      expect(workspace.partition).toMatch(/^persist:workspace-/);
      expect(workspace.createdAt).toBeDefined();
    });

    it("should throw error if name is empty", async () => {
      const config = {
        name: "",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      };

      await expect(workspaceManager.create(config)).rejects.toThrow(
        "Workspace name cannot be empty"
      );
    });

    it("should save workspace to storage", async () => {
      const config = {
        name: "Test Workspace",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      };

      await workspaceManager.create(config);

      expect(mockStorageManager.saveWorkspace).toHaveBeenCalledTimes(1);
      expect(mockStorageManager.saveWorkspace).toHaveBeenCalledWith(
        expect.objectContaining({ name: config.name })
      );
    });

    it("should generate unique IDs for multiple workspaces", async () => {
      const ws1 = await workspaceManager.create({
        name: "WS1",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      const ws2 = await workspaceManager.create({
        name: "WS2",
        icon: "ğŸ ",
        color: "#10B981",
      });

      expect(ws1.id).not.toBe(ws2.id);
      expect(ws1.partition).not.toBe(ws2.partition);
    });
  });

  describe("activate", () => {
    it("should activate workspace and emit event", async () => {
      const workspace = await workspaceManager.create({
        name: "Test",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      const mockCallback = jest.fn();
      workspaceManager.on("workspace-activated", mockCallback);

      await workspaceManager.activate(workspace.id);

      expect(mockCallback).toHaveBeenCalledWith(
        expect.objectContaining({ id: workspace.id })
      );
      expect(workspaceManager.getActive()).toBe(workspace);
    });

    it("should throw error if workspace not found", async () => {
      await expect(workspaceManager.activate("non-existent")).rejects.toThrow(
        "Workspace not found"
      );
    });

    it("should save previous workspace session before switching", async () => {
      const ws1 = await workspaceManager.create({
        name: "WS1",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      const ws2 = await workspaceManager.create({
        name: "WS2",
        icon: "ğŸ ",
        color: "#10B981",
      });

      await workspaceManager.activate(ws1.id);

      const saveSpy = jest.spyOn(workspaceManager, "saveSession");

      await workspaceManager.activate(ws2.id);

      expect(saveSpy).toHaveBeenCalledWith(ws1.id);
    });
  });

  describe("delete", () => {
    it("should delete workspace and clean up resources", async () => {
      const workspace = await workspaceManager.create({
        name: "Test",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      await workspaceManager.delete(workspace.id);

      expect(mockStorageManager.deleteWorkspace).toHaveBeenCalledWith(
        workspace.id
      );
      expect(workspaceManager.get(workspace.id)).toBeNull();
    });

    it("should prevent deleting active workspace", async () => {
      const workspace = await workspaceManager.create({
        name: "Test",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      await workspaceManager.activate(workspace.id);

      await expect(workspaceManager.delete(workspace.id)).rejects.toThrow(
        "Cannot delete active workspace"
      );
    });

    it("should emit delete event", async () => {
      const workspace = await workspaceManager.create({
        name: "Test",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      const mockCallback = jest.fn();
      workspaceManager.on("workspace-deleted", mockCallback);

      await workspaceManager.delete(workspace.id);

      expect(mockCallback).toHaveBeenCalledWith(workspace.id);
    });
  });

  describe("list", () => {
    it("should return all workspaces sorted by order", async () => {
      const ws1 = await workspaceManager.create({
        name: "WS1",
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      const ws2 = await workspaceManager.create({
        name: "WS2",
        icon: "ğŸ ",
        color: "#10B981",
      });

      const list = await workspaceManager.list();

      expect(list).toHaveLength(2);
      expect(list[0].id).toBe(ws1.id);
      expect(list[1].id).toBe(ws2.id);
    });

    it("should return empty array if no workspaces", async () => {
      const list = await workspaceManager.list();
      expect(list).toEqual([]);
    });
  });
});
```

---

#### æµ‹è¯• Storage Manager

```typescript
// src/main/managers/__tests__/StorageManager.test.ts

import { StorageManager } from "../StorageManager";
import fs from "fs/promises";
import path from "path";

// Mock fs
jest.mock("fs/promises");

describe("StorageManager", () => {
  let storageManager: StorageManager;
  const testDbPath = ":memory:"; // ä½¿ç”¨å†…å­˜æ•°æ®åº“æµ‹è¯•

  beforeEach(() => {
    storageManager = new StorageManager(testDbPath);
  });

  afterEach(async () => {
    await storageManager.close();
  });

  describe("initialization", () => {
    it("should create database tables", async () => {
      const tables = await storageManager.getTables();

      expect(tables).toContain("workspaces");
      expect(tables).toContain("tabs");
      expect(tables).toContain("plugin_data");
    });

    it("should create indexes", async () => {
      const indexes = await storageManager.getIndexes();

      expect(indexes).toContain("idx_tabs_workspace");
      expect(indexes).toContain("idx_tabs_active");
    });
  });

  describe("saveWorkspace", () => {
    it("should save workspace to database", async () => {
      const workspace = {
        id: "ws-1",
        name: "Test",
        icon: "ğŸ’¼",
        color: "#3B82F6",
        partition: "persist:workspace-1",
        settings: {},
        tabs: [],
        createdAt: Date.now(),
        lastAccessedAt: Date.now(),
      };

      await storageManager.saveWorkspace(workspace);

      const loaded = await storageManager.loadWorkspace("ws-1");
      expect(loaded).toMatchObject({
        id: workspace.id,
        name: workspace.name,
        icon: workspace.icon,
      });
    });

    it("should update existing workspace", async () => {
      const workspace = {
        id: "ws-1",
        name: "Original Name",
        icon: "ğŸ’¼",
        color: "#3B82F6",
        partition: "persist:workspace-1",
        settings: {},
        tabs: [],
        createdAt: Date.now(),
        lastAccessedAt: Date.now(),
      };

      await storageManager.saveWorkspace(workspace);

      workspace.name = "Updated Name";
      await storageManager.saveWorkspace(workspace);

      const loaded = await storageManager.loadWorkspace("ws-1");
      expect(loaded?.name).toBe("Updated Name");
    });
  });

  describe("loadWorkspace", () => {
    it("should return null if workspace not found", async () => {
      const result = await storageManager.loadWorkspace("non-existent");
      expect(result).toBeNull();
    });

    it("should load workspace with tabs", async () => {
      const workspace = {
        id: "ws-1",
        name: "Test",
        icon: "ğŸ’¼",
        color: "#3B82F6",
        partition: "persist:workspace-1",
        settings: {},
        tabs: [
          {
            id: "tab-1",
            workspaceId: "ws-1",
            url: "https://example.com",
            title: "Example",
            favicon: "",
            active: true,
            suspended: false,
            createdAt: Date.now(),
            lastAccessedAt: Date.now(),
          },
        ],
        createdAt: Date.now(),
        lastAccessedAt: Date.now(),
      };

      await storageManager.saveWorkspace(workspace);
      await storageManager.saveTabs(workspace.id, workspace.tabs);

      const loaded = await storageManager.loadWorkspace("ws-1");
      expect(loaded?.tabs).toHaveLength(1);
      expect(loaded?.tabs[0].url).toBe("https://example.com");
    });
  });

  describe("batch operations", () => {
    it("should save multiple workspaces in transaction", async () => {
      const workspaces = Array.from({ length: 100 }, (_, i) => ({
        id: `ws-${i}`,
        name: `Workspace ${i}`,
        icon: "ğŸ’¼",
        color: "#3B82F6",
        partition: `persist:workspace-${i}`,
        settings: {},
        tabs: [],
        createdAt: Date.now(),
        lastAccessedAt: Date.now(),
      }));

      const startTime = Date.now();
      await storageManager.saveWorkspacesBatch(workspaces);
      const duration = Date.now() - startTime;

      // æ‰¹é‡æ“ä½œåº”è¯¥å¾ˆå¿«
      expect(duration).toBeLessThan(1000);

      const count = await storageManager.countWorkspaces();
      expect(count).toBe(100);
    });
  });

  describe("plugin data isolation", () => {
    it("should isolate plugin data by plugin ID", async () => {
      await storageManager.setPluginData("plugin1", "key", "value1");
      await storageManager.setPluginData("plugin2", "key", "value2");

      const value1 = await storageManager.getPluginData("plugin1", "key");
      const value2 = await storageManager.getPluginData("plugin2", "key");

      expect(value1).toBe("value1");
      expect(value2).toBe("value2");
    });

    it("should clear all data for a plugin", async () => {
      await storageManager.setPluginData("plugin1", "key1", "value1");
      await storageManager.setPluginData("plugin1", "key2", "value2");

      await storageManager.clearPluginData("plugin1");

      const value1 = await storageManager.getPluginData("plugin1", "key1");
      const value2 = await storageManager.getPluginData("plugin1", "key2");

      expect(value1).toBeNull();
      expect(value2).toBeNull();
    });
  });
});
```

---

#### æµ‹è¯• React ç»„ä»¶

```typescript
// src/renderer/components/__tests__/WorkspaceItem.test.tsx

import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { WorkspaceItem } from "../WorkspaceItem";

describe("WorkspaceItem", () => {
  const mockWorkspace = {
    id: "ws-1",
    name: "Test Workspace",
    icon: "ğŸ’¼",
    color: "#3B82F6",
    partition: "persist:workspace-1",
    settings: {},
    tabs: [],
    createdAt: Date.now(),
    lastAccessedAt: Date.now(),
  };

  it("should render workspace name and icon", () => {
    render(
      <WorkspaceItem
        workspace={mockWorkspace}
        active={false}
        onClick={() => {}}
      />
    );

    expect(screen.getByText("Test Workspace")).toBeInTheDocument();
    expect(screen.getByText("ğŸ’¼")).toBeInTheDocument();
  });

  it("should apply active styles when active", () => {
    const { container } = render(
      <WorkspaceItem
        workspace={mockWorkspace}
        active={true}
        onClick={() => {}}
      />
    );

    const button = container.querySelector("button");
    expect(button).toHaveClass("active");
  });

  it("should call onClick when clicked", () => {
    const mockOnClick = jest.fn();

    render(
      <WorkspaceItem
        workspace={mockWorkspace}
        active={false}
        onClick={mockOnClick}
      />
    );

    fireEvent.click(screen.getByRole("button"));

    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });

  it("should show tooltip on hover", async () => {
    render(
      <WorkspaceItem
        workspace={mockWorkspace}
        active={false}
        onClick={() => {}}
      />
    );

    const button = screen.getByRole("button");
    fireEvent.mouseEnter(button);

    // ç­‰å¾… tooltip å‡ºç°
    await screen.findByRole("tooltip");

    expect(screen.getByRole("tooltip")).toHaveTextContent("Test Workspace");
  });
});
```

---

## å››ã€é›†æˆæµ‹è¯•

### 4.1 é›†æˆæµ‹è¯•ç­–ç•¥

#### æµ‹è¯•èŒƒå›´

é›†æˆæµ‹è¯•å…³æ³¨æ¨¡å—é—´çš„äº¤äº’ï¼š

- IPC é€šä¿¡ï¼ˆMain â†” Rendererï¼‰
- æ•°æ®åº“æ“ä½œ
- æ–‡ä»¶ç³»ç»Ÿäº¤äº’
- è¿›ç¨‹é—´åè°ƒ
- äº‹ä»¶ä¼ æ’­

---

### 4.2 é›†æˆæµ‹è¯•ç¤ºä¾‹

#### æµ‹è¯• IPC é€šä¿¡

```typescript
// src/__tests__/integration/ipc.test.ts

import { app, BrowserWindow, ipcMain } from "electron";
import { IPCHandler } from "../../main/ipc/IPCHandler";
import { WorkspaceManager } from "../../main/managers/WorkspaceManager";

describe("IPC Integration", () => {
  let window: BrowserWindow;
  let ipcHandler: IPCHandler;
  let workspaceManager: WorkspaceManager;

  beforeAll(async () => {
    await app.whenReady();
    workspaceManager = new WorkspaceManager();
    ipcHandler = new IPCHandler(workspaceManager);
    ipcHandler.register();
  });

  beforeEach(() => {
    window = new BrowserWindow({
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, "../../preload/index.js"),
      },
    });
  });

  afterEach(() => {
    if (window && !window.isDestroyed()) {
      window.close();
    }
  });

  it("should create workspace via IPC", async () => {
    const config = {
      name: "Test Workspace",
      icon: "ğŸ’¼",
      color: "#3B82F6",
    };

    // ä» Renderer å‘é€ IPC æ¶ˆæ¯
    const result = await window.webContents.executeJavaScript(`
      window.electronAPI.workspace.create(${JSON.stringify(config)})
    `);

    expect(result).toMatchObject({
      name: config.name,
      icon: config.icon,
    });

    // éªŒè¯åç«¯ç¡®å®åˆ›å»ºäº†
    const workspaces = await workspaceManager.list();
    expect(workspaces).toHaveLength(1);
  });

  it("should receive workspace events in renderer", async (done) => {
    // åœ¨ Renderer è®¾ç½®äº‹ä»¶ç›‘å¬
    await window.webContents.executeJavaScript(`
      window.electronAPI.workspace.onActivated((workspace) => {
        window.__testWorkspace = workspace;
      });
    `);

    // åœ¨ Main process æ¿€æ´» workspace
    const workspace = await workspaceManager.create({
      name: "Test",
      icon: "ğŸ’¼",
      color: "#3B82F6",
    });

    await workspaceManager.activate(workspace.id);

    // ç­‰å¾…äº‹ä»¶ä¼ æ’­
    setTimeout(async () => {
      const received = await window.webContents.executeJavaScript(`
        window.__testWorkspace
      `);

      expect(received.id).toBe(workspace.id);
      done();
    }, 100);
  });
});
```

---

#### æµ‹è¯• Workspace åˆ‡æ¢æµç¨‹

```typescript
// src/__tests__/integration/workspace-switch.test.ts

describe("Workspace Switch Integration", () => {
  let workspaceManager: WorkspaceManager;
  let tabManager: TabManager;
  let webViewPoolManager: WebViewPoolManager;

  beforeEach(() => {
    workspaceManager = new WorkspaceManager();
    tabManager = new TabManager();
    webViewPoolManager = new WebViewPoolManager();
  });

  it("should save and restore tabs when switching workspaces", async () => {
    // åˆ›å»ºä¸¤ä¸ª workspaces
    const ws1 = await workspaceManager.create({
      name: "WS1",
      icon: "ğŸ’¼",
      color: "#3B82F6",
    });

    const ws2 = await workspaceManager.create({
      name: "WS2",
      icon: "ğŸ ",
      color: "#10B981",
    });

    // åœ¨ WS1 åˆ›å»º tabs
    await workspaceManager.activate(ws1.id);
    const tab1 = await tabManager.create(ws1.id, "https://example1.com");
    const tab2 = await tabManager.create(ws1.id, "https://example2.com");

    // åˆ‡æ¢åˆ° WS2
    await workspaceManager.activate(ws2.id);

    // éªŒè¯ WS1 çš„ tabs è¢«ä¿å­˜
    expect(ws1.tabs).toHaveLength(2);

    // éªŒè¯å½“å‰æ²¡æœ‰æ´»è·ƒçš„ tabs
    const activeTabs = tabManager.getTabsForWorkspace(ws2.id);
    expect(activeTabs).toHaveLength(0);

    // åˆ‡æ¢å› WS1
    await workspaceManager.activate(ws1.id);

    // éªŒè¯ tabs è¢«æ¢å¤
    const restoredTabs = tabManager.getTabsForWorkspace(ws1.id);
    expect(restoredTabs).toHaveLength(2);
    expect(restoredTabs[0].url).toBe("https://example1.com");
    expect(restoredTabs[1].url).toBe("https://example2.com");
  });

  it("should isolate sessions between workspaces", async () => {
    const ws1 = await workspaceManager.create({
      name: "WS1",
      icon: "ğŸ’¼",
      color: "#3B82F6",
    });

    const ws2 = await workspaceManager.create({
      name: "WS2",
      icon: "ğŸ ",
      color: "#10B981",
    });

    const session1 = sessionController.getSession(ws1.id);
    const session2 = sessionController.getSession(ws2.id);

    // éªŒè¯ä¸åŒçš„ partition
    expect(session1.partition).not.toBe(session2.partition);

    // åœ¨ session1 è®¾ç½® cookie
    await session1.cookies.set({
      url: "https://example.com",
      name: "test",
      value: "value1",
    });

    // åœ¨ session2 æ£€æŸ¥ cookieï¼ˆåº”è¯¥ä¸å­˜åœ¨ï¼‰
    const cookies = await session2.cookies.get({
      url: "https://example.com",
    });

    expect(cookies).toHaveLength(0);
  });
});
```

---

## äº”ã€E2E æµ‹è¯•

### 5.1 E2E æµ‹è¯•ç­–ç•¥

#### Playwright é…ç½®

```typescript
// playwright.config.ts

import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  testDir: "./e2e",
  timeout: 30000,
  fullyParallel: false, // Electron æµ‹è¯•é€šå¸¸ä¸å¹¶è¡Œ
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: 1,

  reporter: [["html"], ["junit", { outputFile: "test-results/junit.xml" }]],

  use: {
    trace: "on-first-retry",
    screenshot: "only-on-failure",
    video: "retain-on-failure",
  },

  projects: [
    {
      name: "electron",
      use: {
        ...devices["Desktop Chrome"],
        // Electron specific settings
      },
    },
  ],
});
```

---

### 5.2 E2E æµ‹è¯•ç¤ºä¾‹

#### æµ‹è¯•å®Œæ•´å·¥ä½œæµ

```typescript
// e2e/workspace-management.spec.ts

import { test, expect, _electron as electron } from "@playwright/test";
import path from "path";

test.describe("Workspace Management", () => {
  let electronApp: any;
  let window: any;

  test.beforeAll(async () => {
    electronApp = await electron.launch({
      args: [path.join(__dirname, "../dist/main/index.js")],
    });

    window = await electronApp.firstWindow();
    await window.waitForLoadState("domcontentloaded");
  });

  test.afterAll(async () => {
    await electronApp.close();
  });

  test("should create a new workspace", async () => {
    // ç‚¹å‡»"Add Workspace"æŒ‰é’®
    await window.click('[data-testid="add-workspace"]');

    // å¡«å†™è¡¨å•
    await window.fill('[data-testid="workspace-name"]', "My Test Workspace");
    await window.click('[data-testid="icon-picker"]');
    await window.click('[data-testid="icon-ğŸ’¼"]');

    // æäº¤
    await window.click('[data-testid="create-button"]');

    // éªŒè¯æ–° workspace å‡ºç°åœ¨åˆ—è¡¨ä¸­
    await expect(window.locator("text=My Test Workspace")).toBeVisible();
  });

  test("should switch between workspaces", async () => {
    // åˆ›å»ºç¬¬äºŒä¸ª workspace
    await window.click('[data-testid="add-workspace"]');
    await window.fill('[data-testid="workspace-name"]', "Second Workspace");
    await window.click('[data-testid="create-button"]');

    // ç‚¹å‡»ç¬¬ä¸€ä¸ª workspace
    await window.click('[data-testid="workspace-item-0"]');

    // éªŒè¯å·²æ¿€æ´»ï¼ˆé€šè¿‡æ ·å¼ç±»ï¼‰
    await expect(
      window.locator('[data-testid="workspace-item-0"]')
    ).toHaveClass(/active/);

    // åˆ‡æ¢åˆ°ç¬¬äºŒä¸ª workspace
    await window.click('[data-testid="workspace-item-1"]');

    // éªŒè¯åˆ‡æ¢æˆåŠŸ
    await expect(
      window.locator('[data-testid="workspace-item-1"]')
    ).toHaveClass(/active/);
    await expect(
      window.locator('[data-testid="workspace-item-0"]')
    ).not.toHaveClass(/active/);
  });

  test("should create and manage tabs in workspace", async () => {
    // ç¡®ä¿åœ¨ä¸€ä¸ª workspace ä¸­
    await window.click('[data-testid="workspace-item-0"]');

    // åˆ›å»ºæ–° Tab
    await window.click('[data-testid="new-tab"]');

    // è¾“å…¥ URL
    await window.fill('[data-testid="url-input"]', "https://example.com");
    await window.press('[data-testid="url-input"]', "Enter");

    // ç­‰å¾… Tab åŠ è½½
    await window.waitForSelector('[data-testid="tab-item"]');

    // éªŒè¯ Tab å‡ºç°
    await expect(window.locator('[data-testid="tab-item"]')).toBeVisible();

    // åˆ›å»ºç¬¬äºŒä¸ª Tab
    await window.click('[data-testid="new-tab"]');
    await window.fill('[data-testid="url-input"]', "https://example2.com");
    await window.press('[data-testid="url-input"]', "Enter");

    // éªŒè¯æœ‰ä¸¤ä¸ª Tabs
    await expect(window.locator('[data-testid="tab-item"]')).toHaveCount(2);

    // å…³é—­ç¬¬ä¸€ä¸ª Tab
    await window.hover('[data-testid="tab-item"]:nth-child(1)');
    await window.click(
      '[data-testid="tab-item"]:nth-child(1) [data-testid="close-tab"]'
    );

    // éªŒè¯åªå‰©ä¸€ä¸ª Tab
    await expect(window.locator('[data-testid="tab-item"]')).toHaveCount(1);
  });

  test("should persist state after restart", async () => {
    // åˆ›å»º workspace å’Œ tabs
    await window.click('[data-testid="add-workspace"]');
    await window.fill('[data-testid="workspace-name"]', "Persistent Workspace");
    await window.click('[data-testid="create-button"]');

    await window.click('[data-testid="new-tab"]');
    await window.fill('[data-testid="url-input"]', "https://persistent.com");
    await window.press('[data-testid="url-input"]', "Enter");

    // å…³é—­åº”ç”¨
    await electronApp.close();

    // é‡æ–°å¯åŠ¨
    electronApp = await electron.launch({
      args: [path.join(__dirname, "../dist/main/index.js")],
    });
    window = await electronApp.firstWindow();

    // éªŒè¯æ•°æ®æ¢å¤
    await expect(window.locator("text=Persistent Workspace")).toBeVisible();
    await window.click("text=Persistent Workspace");
    await expect(window.locator('[data-testid="tab-item"]')).toBeVisible();
  });

  test("should delete workspace", async () => {
    // åˆ›å»ºä¸€ä¸ª workspace
    await window.click('[data-testid="add-workspace"]');
    await window.fill('[data-testid="workspace-name"]', "To Be Deleted");
    await window.click('[data-testid="create-button"]');

    // å³é”®èœå•
    await window.click('[data-testid="workspace-item"]:last-child', {
      button: "right",
    });

    // ç‚¹å‡»åˆ é™¤
    await window.click('[data-testid="context-menu-delete"]');

    // ç¡®è®¤å¯¹è¯æ¡†
    await window.click('[data-testid="confirm-delete"]');

    // éªŒè¯å·²åˆ é™¤
    await expect(window.locator("text=To Be Deleted")).not.toBeVisible();
  });
});
```

---

#### æµ‹è¯•ä¼šè¯éš”ç¦»

```typescript
// e2e/session-isolation.spec.ts

test.describe("Session Isolation", () => {
  let electronApp: any;
  let window: any;

  test.beforeAll(async () => {
    electronApp = await electron.launch({
      args: [path.join(__dirname, "../dist/main/index.js")],
    });
    window = await electronApp.firstWindow();
  });

  test.afterAll(async () => {
    await electronApp.close();
  });

  test("should isolate cookies between workspaces", async () => {
    // åˆ›å»ºä¸¤ä¸ª workspaces
    await createWorkspace(window, "WS1", "ğŸ’¼");
    await createWorkspace(window, "WS2", "ğŸ ");

    // åœ¨ WS1 ä¸­è®¿é—®ç½‘ç«™å¹¶è®¾ç½® cookie
    await window.click("text=WS1");
    await window.click('[data-testid="new-tab"]');
    await window.fill(
      '[data-testid="url-input"]',
      "http://localhost:3000/test-cookie"
    );
    await window.press('[data-testid="url-input"]', "Enter");

    // ç­‰å¾…é¡µé¢åŠ è½½å¹¶è®¾ç½® cookie
    await window.waitForTimeout(1000);

    // è·å– cookie å€¼ï¼ˆé€šè¿‡æ³¨å…¥è„šæœ¬ï¼‰
    const cookie1 = await window.evaluate(() => {
      return document.cookie;
    });

    expect(cookie1).toContain("test=value1");

    // åˆ‡æ¢åˆ° WS2
    await window.click("text=WS2");
    await window.click('[data-testid="new-tab"]');
    await window.fill(
      '[data-testid="url-input"]',
      "http://localhost:3000/test-cookie"
    );
    await window.press('[data-testid="url-input"]', "Enter");

    await window.waitForTimeout(1000);

    // WS2 ä¸­åº”è¯¥æ²¡æœ‰ cookie
    const cookie2 = await window.evaluate(() => {
      return document.cookie;
    });

    expect(cookie2).not.toContain("test=value1");

    // åœ¨ WS2 è®¾ç½®ä¸åŒçš„ cookie
    await window.evaluate(() => {
      document.cookie = "test=value2";
    });

    // åˆ‡æ¢å› WS1ï¼ŒéªŒè¯ cookie æ²¡æœ‰è¢«è¦†ç›–
    await window.click("text=WS1");
    const cookie1Again = await window.evaluate(() => {
      return document.cookie;
    });

    expect(cookie1Again).toContain("test=value1");
    expect(cookie1Again).not.toContain("test=value2");
  });

  test("should isolate localStorage between workspaces", async () => {
    // åœ¨ WS1 è®¾ç½® localStorage
    await window.click("text=WS1");
    await window.evaluate(() => {
      localStorage.setItem("testKey", "value1");
    });

    // åˆ‡æ¢åˆ° WS2
    await window.click("text=WS2");
    const value = await window.evaluate(() => {
      return localStorage.getItem("testKey");
    });

    expect(value).toBeNull();

    // åœ¨ WS2 è®¾ç½®ä¸åŒçš„å€¼
    await window.evaluate(() => {
      localStorage.setItem("testKey", "value2");
    });

    // åˆ‡æ¢å› WS1ï¼ŒéªŒè¯å€¼æ²¡å˜
    await window.click("text=WS1");
    const value1 = await window.evaluate(() => {
      return localStorage.getItem("testKey");
    });

    expect(value1).toBe("value1");
  });
});

// è¾…åŠ©å‡½æ•°
async function createWorkspace(window: any, name: string, icon: string) {
  await window.click('[data-testid="add-workspace"]');
  await window.fill('[data-testid="workspace-name"]', name);
  await window.click(`[data-testid="icon-${icon}"]`);
  await window.click('[data-testid="create-button"]');
}
```

---

#### æµ‹è¯•æ€§èƒ½

```typescript
// e2e/performance.spec.ts

test.describe("Performance", () => {
  let electronApp: any;
  let window: any;

  test.beforeAll(async () => {
    electronApp = await electron.launch({
      args: [path.join(__dirname, "../dist/main/index.js")],
    });
    window = await electronApp.firstWindow();
  });

  test.afterAll(async () => {
    await electronApp.close();
  });

  test("startup time should be under 3 seconds", async () => {
    const startTime = Date.now();

    // ç­‰å¾…åº”ç”¨å®Œå…¨åŠ è½½
    await window.waitForSelector('[data-testid="workspace-list"]');

    const loadTime = Date.now() - startTime;

    expect(loadTime).toBeLessThan(3000);
    console.log(`Startup time: ${loadTime}ms`);
  });

  test("workspace switch should be under 500ms", async () => {
    // åˆ›å»ºä¸¤ä¸ª workspaces
    await createWorkspace(window, "WS1", "ğŸ’¼");
    await createWorkspace(window, "WS2", "ğŸ ");

    // æµ‹é‡åˆ‡æ¢æ—¶é—´
    const startTime = Date.now();
    await window.click("text=WS2");

    // ç­‰å¾…åˆ‡æ¢å®Œæˆï¼ˆactive ç±»åº”ç”¨ï¼‰
    await window.waitForSelector(
      '[data-testid="workspace-item"].active:has-text("WS2")'
    );

    const switchTime = Date.now() - startTime;

    expect(switchTime).toBeLessThan(500);
    console.log(`Workspace switch time: ${switchTime}ms`);
  });

  test("should handle many tabs without crashing", async () => {
    await window.click('[data-testid="workspace-item-0"]');

    // åˆ›å»º 50 ä¸ª tabs
    for (let i = 0; i < 50; i++) {
      await window.click('[data-testid="new-tab"]');
      await window.fill('[data-testid="url-input"]', `https://example${i}.com`);
      await window.press('[data-testid="url-input"]', "Enter");

      // ç­‰å¾…ä¸€å°ä¼šå„¿é¿å…è¿‡å¿«
      await window.waitForTimeout(100);
    }

    // éªŒè¯æ‰€æœ‰ tabs éƒ½åˆ›å»ºäº†
    await expect(window.locator('[data-testid="tab-item"]')).toHaveCount(50);

    // åº”ç”¨åº”è¯¥ä»ç„¶å“åº”
    await window.click('[data-testid="tab-item"]:first-child');
    await expect(
      window.locator('[data-testid="tab-item"]:first-child')
    ).toHaveClass(/active/);
  });

  test("memory usage should be reasonable", async () => {
    // åˆ›å»ºå¤šä¸ª workspaces å’Œ tabs
    for (let i = 0; i < 5; i++) {
      await createWorkspace(window, `WS${i}`, "ğŸ’¼");

      for (let j = 0; j < 10; j++) {
        await window.click('[data-testid="new-tab"]');
        await window.fill(
          '[data-testid="url-input"]',
          `https://example${j}.com`
        );
        await window.press('[data-testid="url-input"]', "Enter");
      }
    }

    // è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
    const metrics = await electronApp.evaluate(async ({ app }) => {
      return process.getProcessMemoryInfo();
    });

    console.log("Memory usage:", metrics);

    // å†…å­˜åº”è¯¥å°äº 2GB
    expect(metrics.private).toBeLessThan(2 * 1024 * 1024); // KB
  });
});
```

---

## å…­ã€æ€§èƒ½æµ‹è¯•

### 6.1 æ€§èƒ½åŸºå‡†æµ‹è¯•

```typescript
// tests/performance/benchmark.test.ts

import { performance } from "perf_hooks";

describe("Performance Benchmarks", () => {
  let workspaceManager: WorkspaceManager;

  beforeEach(() => {
    workspaceManager = new WorkspaceManager();
  });

  describe("Workspace Operations", () => {
    it("should create workspace in under 50ms", async () => {
      const iterations = 100;
      const times: number[] = [];

      for (let i = 0; i < iterations; i++) {
        const start = performance.now();

        await workspaceManager.create({
          name: `Workspace ${i}`,
          icon: "ğŸ’¼",
          color: "#3B82F6",
        });

        const duration = performance.now() - start;
        times.push(duration);
      }

      const average = times.reduce((a, b) => a + b) / times.length;
      const p95 = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];

      console.log(
        `Create workspace - Average: ${average.toFixed(
          2
        )}ms, P95: ${p95.toFixed(2)}ms`
      );

      expect(average).toBeLessThan(50);
      expect(p95).toBeLessThan(100);
    });

    it("should switch workspace in under 200ms", async () => {
      // åˆ›å»º 10 ä¸ª workspaces
      const workspaces = await Promise.all(
        Array.from({ length: 10 }, (_, i) =>
          workspaceManager.create({
            name: `WS${i}`,
            icon: "ğŸ’¼",
            color: "#3B82F6",
          })
        )
      );

      const times: number[] = [];

      // æµ‹é‡åˆ‡æ¢æ—¶é—´
      for (let i = 0; i < workspaces.length; i++) {
        const start = performance.now();
        await workspaceManager.activate(workspaces[i].id);
        const duration = performance.now() - start;
        times.push(duration);
      }

      const average = times.reduce((a, b) => a + b) / times.length;
      const p95 = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];

      console.log(
        `Switch workspace - Average: ${average.toFixed(
          2
        )}ms, P95: ${p95.toFixed(2)}ms`
      );

      expect(average).toBeLessThan(200);
      expect(p95).toBeLessThan(500);
    });
  });

  describe("Database Operations", () => {
    it("should batch save 1000 workspaces in under 1 second", async () => {
      const workspaces = Array.from({ length: 1000 }, (_, i) => ({
        id: `ws-${i}`,
        name: `Workspace ${i}`,
        icon: "ğŸ’¼",
        color: "#3B82F6",
        partition: `persist:workspace-${i}`,
        settings: {},
        tabs: [],
        createdAt: Date.now(),
        lastAccessedAt: Date.now(),
      }));

      const start = performance.now();
      await storageManager.saveWorkspacesBatch(workspaces);
      const duration = performance.now() - start;

      console.log(`Batch save 1000 workspaces: ${duration.toFixed(2)}ms`);

      expect(duration).toBeLessThan(1000);
    });

    it("should query workspaces in under 10ms", async () => {
      // æ’å…¥ 1000 ä¸ª workspaces
      const workspaces = Array.from({ length: 1000 }, (_, i) => ({
        id: `ws-${i}`,
        name: `Workspace ${i}`,
        icon: "ğŸ’¼",
        color: "#3B82F6",
        partition: `persist:workspace-${i}`,
        settings: {},
        tabs: [],
        createdAt: Date.now(),
        lastAccessedAt: Date.now(),
      }));

      await storageManager.saveWorkspacesBatch(workspaces);

      // æµ‹é‡æŸ¥è¯¢æ—¶é—´
      const times: number[] = [];

      for (let i = 0; i < 100; i++) {
        const start = performance.now();
        await storageManager.loadAllWorkspaces();
        const duration = performance.now() - start;
        times.push(duration);
      }

      const average = times.reduce((a, b) => a + b) / times.length;

      console.log(`Query workspaces average: ${average.toFixed(2)}ms`);

      expect(average).toBeLessThan(10);
    });
  });
});
```

---

### 6.2 è´Ÿè½½æµ‹è¯•

```typescript
// tests/performance/load-test.test.ts

describe("Load Tests", () => {
  it("should handle 100 concurrent workspace operations", async () => {
    const operations = Array.from({ length: 100 }, async (_, i) => {
      const ws = await workspaceManager.create({
        name: `Concurrent WS ${i}`,
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      // åˆ›å»º tabs
      for (let j = 0; j < 5; j++) {
        await tabManager.create(ws.id, `https://example${j}.com`);
      }

      // åˆ‡æ¢å‡ æ¬¡
      await workspaceManager.activate(ws.id);

      return ws;
    });

    const start = performance.now();
    const results = await Promise.all(operations);
    const duration = performance.now() - start;

    console.log(`100 concurrent operations: ${duration.toFixed(2)}ms`);

    expect(results).toHaveLength(100);
    expect(duration).toBeLessThan(10000); // 10 ç§’å†…å®Œæˆ
  });

  it("should maintain performance under memory pressure", async () => {
    // åˆ›å»ºå¤§é‡æ•°æ®
    const workspaces = await Promise.all(
      Array.from({ length: 50 }, (_, i) =>
        workspaceManager.create({
          name: `WS${i}`,
          icon: "ğŸ’¼",
          color: "#3B82F6",
        })
      )
    );

    // æ¯ä¸ª workspace åˆ›å»º 20 ä¸ª tabs
    for (const ws of workspaces) {
      await Promise.all(
        Array.from({ length: 20 }, (_, i) =>
          tabManager.create(ws.id, `https://example${i}.com`)
        )
      );
    }

    // æµ‹é‡åˆ‡æ¢æ€§èƒ½
    const times: number[] = [];

    for (let i = 0; i < 20; i++) {
      const ws = workspaces[Math.floor(Math.random() * workspaces.length)];
      const start = performance.now();
      await workspaceManager.activate(ws.id);
      const duration = performance.now() - start;
      times.push(duration);
    }

    const average = times.reduce((a, b) => a + b) / times.length;

    console.log(`Performance under load - Average: ${average.toFixed(2)}ms`);

    // å³ä½¿åœ¨é«˜è´Ÿè½½ä¸‹ï¼Œæ€§èƒ½ä¹Ÿåº”è¯¥å¯æ¥å—
    expect(average).toBeLessThan(1000); // 1 ç§’
  });
});
```

---

## ä¸ƒã€å®‰å…¨æµ‹è¯•

### 7.1 å®‰å…¨æµ‹è¯•ç­–ç•¥

```typescript
// tests/security/plugin-sandbox.test.ts

describe("Plugin Sandbox Security", () => {
  let pluginHost: PluginHost;

  beforeEach(() => {
    pluginHost = new PluginHost();
  });

  it("should prevent access to Node.js APIs", async () => {
    const maliciousPlugin = `
      export function activate(api) {
        // å°è¯•è®¿é—® require
        try {
          const fs = require('fs');
          return { hasAccess: true };
        } catch (error) {
          return { hasAccess: false, error: error.message };
        }
      }
    `;

    const tempDir = await createTempPlugin("malicious", maliciousPlugin);

    await pluginHost.load(tempDir);

    const plugin = pluginHost.getPlugin("com.test.malicious");
    expect(plugin.result.hasAccess).toBe(false);
  });

  it("should prevent access to process object", async () => {
    const maliciousPlugin = `
      export function activate(api) {
        try {
          return { cwd: process.cwd() };
        } catch (error) {
          return { error: error.message };
        }
      }
    `;

    const tempDir = await createTempPlugin("process-test", maliciousPlugin);
    await pluginHost.load(tempDir);

    const plugin = pluginHost.getPlugin("com.test.process-test");
    expect(plugin.result.error).toBeDefined();
  });

  it("should enforce HTTP permission restrictions", async () => {
    const plugin = `
      export async function activate(api) {
        try {
          // å°è¯•è®¿é—®æœªæˆæƒçš„åŸŸå
          await api.http.fetch('https://unauthorized.com');
          return { success: true };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
    `;

    const manifest = {
      id: "com.test.http-test",
      name: "HTTP Test",
      version: "1.0.0",
      main: "index.js",
      author: { name: "Test" },
      engines: { "workspace-os": ">=1.0.0" },
      permissions: ["http:https://allowed.com/*"], // åªå…è®¸è¿™ä¸ªåŸŸå
    };

    const tempDir = await createTempPlugin("http-test", plugin, manifest);
    await pluginHost.load(tempDir);

    const loadedPlugin = pluginHost.getPlugin("com.test.http-test");
    expect(loadedPlugin.result.success).toBe(false);
    expect(loadedPlugin.result.error).toContain("not allowed");
  });

  it("should timeout long-running plugin code", async () => {
    const infiniteLoopPlugin = `
      export function activate(api) {
        while(true) {
          // æ— é™å¾ªç¯
        }
      }
    `;

    const tempDir = await createTempPlugin("infinite-loop", infiniteLoopPlugin);

    await expect(pluginHost.load(tempDir)).rejects.toThrow(/timeout/i);
  });

  it("should enforce storage limits", async () => {
    const plugin = `
      export async function activate(api) {
        try {
          // å°è¯•å­˜å‚¨è¶…è¿‡é™åˆ¶çš„æ•°æ®
          const largeData = 'x'.repeat(20 * 1024 * 1024); // 20MB
          await api.storage.set('large', largeData);
          return { success: true };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
    `;

    const tempDir = await createTempPlugin("storage-test", plugin, {
      id: "com.test.storage",
      name: "Storage Test",
      version: "1.0.0",
      main: "index.js",
      author: { name: "Test" },
      engines: { "workspace-os": ">=1.0.0" },
      permissions: ["storage"],
    });

    await pluginHost.load(tempDir);

    const loadedPlugin = pluginHost.getPlugin("com.test.storage");
    expect(loadedPlugin.result.success).toBe(false);
    expect(loadedPlugin.result.error).toContain("limit exceeded");
  });
});
```

---

### 7.2 æ¸—é€æµ‹è¯•æ¸…å•

```typescript
// tests/security/penetration-tests.test.ts

describe("Penetration Tests", () => {
  describe("XSS Prevention", () => {
    it("should sanitize user input in workspace name", async () => {
      const xssPayload = '<script>alert("XSS")</script>';

      const workspace = await workspaceManager.create({
        name: xssPayload,
        icon: "ğŸ’¼",
        color: "#3B82F6",
      });

      // éªŒè¯åœ¨ UI ä¸­æ¸²æŸ“æ—¶ä¸ä¼šæ‰§è¡Œè„šæœ¬
      const rendered = await renderWorkspaceItem(workspace);
      expect(rendered).not.toContain("<script>");
      expect(rendered).toContain("&lt;script&gt;");
    });
  });

  describe("SQL Injection Prevention", () => {
    it("should prevent SQL injection in workspace queries", async () => {
      const sqlInjection = "'; DROP TABLE workspaces; --";

      // å°è¯•æ³¨å…¥
      try {
        await workspaceManager.create({
          name: sqlInjection,
          icon: "ğŸ’¼",
          color: "#3B82F6",
        });
      } catch (error) {
        // å¯èƒ½æŠ›å‡ºé”™è¯¯ï¼Œè¿™æ˜¯å¯ä»¥çš„
      }

      // éªŒè¯è¡¨ä»ç„¶å­˜åœ¨
      const workspaces = await storageManager.loadAllWorkspaces();
      expect(workspaces).toBeDefined();
    });
  });

  describe("Path Traversal Prevention", () => {
    it("should prevent path traversal in plugin loading", async () => {
      const maliciousPath = "../../../etc/passwd";

      await expect(pluginHost.load(maliciousPath)).rejects.toThrow();
    });
  });

  describe("CSRF Prevention", () => {
    it("should validate IPC messages origin", async () => {
      // æ¨¡æ‹Ÿæ¥è‡ªæ¶æ„æºçš„ IPC æ¶ˆæ¯
      const fakeEvent = {
        sender: {
          getURL: () => "https://evil.com",
        },
      };

      await expect(
        ipcHandler.handle(fakeEvent as any, "workspace:create", {})
      ).rejects.toThrow(/invalid origin/i);
    });
  });
});
```

---

## å…«ã€æµ‹è¯•è‡ªåŠ¨åŒ–

### 8.1 CI/CD é›†æˆ

#### GitHub Actions é…ç½®

```yaml
# .github/workflows/test.yml

name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18.x, 20.x]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json
          flags: unittests
          name: codecov-${{ matrix.os }}-${{ matrix.node-version }}

  integration-tests:
    name: Integration Tests
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18.x

      - name: Install dependencies
        run: npm ci

      - name: Run integration tests
        run: npm run test:integration

  e2e-tests:
    name: E2E Tests
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18.x

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright
        run: npx playwright install --with-deps

      - name: Build application
        run: npm run build

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report-${{ matrix.os }}
          path: playwright-report/

  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18.x

      - name: Install dependencies
        run: npm ci

      - name: Run performance tests
        run: npm run test:performance

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: performance-results.json

      - name: Check performance regression
        run: node scripts/check-performance-regression.js
```

---

### 8.2 æµ‹è¯•è„šæœ¬

```json
// package.json

{
  "scripts": {
    "test": "npm run test:unit && npm run test:integration && npm run test:e2e",
    "test:unit": "jest --config jest.config.js",
    "test:unit:watch": "jest --watch",
    "test:unit:coverage": "jest --coverage",
    "test:integration": "jest --config jest.config.js --selectProjects integration",
    "test:e2e": "playwright test",
    "test:performance": "jest --config tests/performance/jest.config.js",
    "test:security": "jest --config tests/security/jest.config.js"
  }
}
```

---

## ä¹ã€æµ‹è¯•çŸ©é˜µä¸å‘å¸ƒé—¨æ§›

- æ“ä½œç³»ç»Ÿï¼š`Windows`, `macOS`, `Linux`ï¼ˆè‡³å°‘ 2 ä¸ªå¹³å°åŒæ—¶é€šè¿‡ï¼‰
- Node/Electronï¼šNode `18.x/20.x`ï¼ŒElectron ç›®æ ‡ç‰ˆæœ¬ä¸æ¬¡ç‰ˆæœ¬ï¼ˆå« GPU on/offï¼‰
- è¦†ç›–ç‡é—¸é—¨ï¼šå…¨å±€ 70%+ï¼Œæ ¸å¿ƒæ¨¡å—ï¼ˆmanagersï¼‰80%+ï¼›ä¸è¾¾æ ‡ PR é˜»å¡
- å¤±è´¥åˆ†ç±»ï¼š`P0`ï¼ˆé˜»å¡å‘å¸ƒï¼‰ã€`P1`ï¼ˆéœ€ä¿®å¤å†åˆå¹¶ï¼‰ã€`P2`ï¼ˆå…è®¸è·Ÿè¿›ï¼‰
- å‘å¸ƒå‡†å…¥ï¼š`unit/integration/e2e` å…¨ç»¿ï¼›æ—  `P0`ï¼›æ€§èƒ½é¢„ç®—æ»¡è¶³ï¼ˆè§ä¸‹ï¼‰

## åã€æ€§èƒ½é¢„ç®—ä¸å›å½’

- å¯åŠ¨æ—¶å»¶ `< 3000ms`ï¼ŒWorkspace åˆ‡æ¢ `< 500ms`ï¼Œæ‰¹é‡æ“ä½œï¼ˆ1000 é¡¹ï¼‰`< 1000ms`
- å†…å­˜å ç”¨ï¼šå…¸å‹ä¼šè¯ `< 2GB`ï¼ˆè¿›ç¨‹ç§æœ‰å†…å­˜ï¼‰ï¼›å¼‚å¸¸å ç”¨éœ€å‘Šè­¦
- CI æ¯”å¯¹ï¼šä¿å­˜å†å²åŸºçº¿ï¼Œå›å½’å¤§äºé˜ˆå€¼åˆ™å¤±è´¥å¹¶è¾“å‡ºå·®å¼‚æŠ¥å‘Š

## åä¸€ã€Flaky æµ‹è¯•ç®¡ç†

- è¯†åˆ«ä¸éš”ç¦»ï¼šæ ‡è®°ä¸º `@flaky`ï¼Œå•ç‹¬é¡¹ç›®è¿è¡Œä¸é‡è¯•ï¼ˆCI ä¸‹æœ€å¤š 2 æ¬¡ï¼‰
- æ ¹å› åˆ†æï¼šç½‘ç»œ/æ—¶åº/å¼‚æ­¥èµ„æºé‡Šæ”¾ï¼›å®Œå–„ç­‰å¾…æ¡ä»¶ä¸è¶…æ—¶æ§åˆ¶
- æ¸…ç†ç­–ç•¥ï¼šç¨³å®šåç§»é™¤ `@flaky` æ ‡ç­¾å¹¶åˆæµåˆ°æ­£å¸¸é¡¹ç›®

## åäºŒã€æµ‹è¯•æ•°æ®ä¸è„±æ•

- æµ‹è¯•æ•°æ®ç”Ÿæˆï¼šä½¿ç”¨å›ºå®šç§å­ä¸å·¥å‚æ–¹æ³•ï¼›ç¦æ­¢çœŸå®æ•æ„Ÿæ•°æ®
- æ•°æ®éš”ç¦»ï¼šæ¯æ¡æµ‹è¯•ç‹¬ç«‹å·¥ä½œç›®å½•/æ•°æ®åº“ï¼›æ‰§è¡Œåæ¸…ç†
- æ—¥å¿—è„±æ•ï¼šè´¦å·ã€ä»¤ç‰Œã€Cookie ä»¥æ©ç è®°å½•ï¼›å·¥ä»¶ä¸Šä¼ å‰æ£€æŸ¥

> å…¨é¢çš„æµ‹è¯•ç­–ç•¥ï¼Œç¡®ä¿è½¯ä»¶è´¨é‡ã€ç¨³å®šæ€§å’Œå¯é æ€§

---
