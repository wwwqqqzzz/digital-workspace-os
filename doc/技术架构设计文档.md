# Digital Workspace OS — 技术架构设计文档

> 定义系统的核心架构、数据模型、模块划分和关键技术决策

---

## 一、系统架构总览

### 1.1 多进程架构（Electron）

```
┌─────────────────────────────────────────────────────────────┐
│                        Main Process                          │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Application Controller                                 │ │
│  │  - Workspace Manager                                    │ │
│  │  - Session Controller (Partitions)                      │ │
│  │  - WebView Pool Manager                                 │ │
│  │  - Plugin Host                                          │ │
│  │  - Storage Manager (SQLite + JSON)                      │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                           ↕ IPC
┌─────────────────────────────────────────────────────────────┐
│                     Renderer Process (UI)                    │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  React Application                                      │ │
│  │  ├─ Sidebar (Workspace List)                            │ │
│  │  ├─ Content Area (WebView Container)                    │ │
│  │  ├─ Tab Bar                                             │ │
│  │  ├─ Command Palette                                     │ │
│  │  └─ Settings Panel                                      │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                           ↕ IPC
┌─────────────────────────────────────────────────────────────┐
│                    Preload Scripts (Bridge)                  │
│  - Exposed API (contextBridge)                              │
│  - Security Layer                                           │
│  - Plugin Injection Points                                  │
└─────────────────────────────────────────────────────────────┘
                           ↕
┌─────────────────────────────────────────────────────────────┐
│              BrowserView Instances (WebViews)                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ WebView1 │  │ WebView2 │  │ WebView3 │  │   ...    │   │
│  │(Gmail)   │  │(Notion)  │  │(Discord) │  │          │   │
│  │Session:W1│  │Session:W1│  │Session:W2│  │          │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、核心模块详细设计

### 2.1 Workspace Manager（工作空间管理器）

**职责：**

- Workspace 的 CRUD 操作
- Workspace 状态管理和持久化
- Workspace 切换逻辑

**接口定义：**

```typescript
interface IWorkspaceManager {
  // CRUD
  create(config: WorkspaceConfig): Promise<Workspace>;
  get(id: string): Promise<Workspace | null>;
  list(): Promise<Workspace[]>;
  update(id: string, updates: Partial<WorkspaceConfig>): Promise<void>;
  delete(id: string): Promise<void>;

  // 状态管理
  activate(id: string): Promise<void>;
  deactivate(id: string): Promise<void>;
  getActive(): Workspace | null;

  // 会话管理
  saveSession(id: string): Promise<void>;
  restoreSession(id: string): Promise<void>;

  // 导入导出
  export(id: string): Promise<WorkspaceExport>;
  import(data: WorkspaceExport): Promise<Workspace>;
}
```

**实现要点：**

```typescript
class WorkspaceManager implements IWorkspaceManager {
  private workspaces: Map<string, Workspace> = new Map();
  private activeWorkspaceId: string | null = null;
  private storage: StorageManager;

  async create(config: WorkspaceConfig): Promise<Workspace> {
    const workspace: Workspace = {
      id: generateId(),
      name: config.name,
      icon: config.icon || "default",
      color: config.color || "#3B82F6",
      partition: `persist:workspace-${generateId()}`,
      tabs: [],
      settings: {
        autoSuspendTabs: true,
        suspendAfterMinutes: 30,
        enabledPlugins: [],
        ...config.settings,
      },
      createdAt: Date.now(),
      lastAccessedAt: Date.now(),
    };

    this.workspaces.set(workspace.id, workspace);
    await this.storage.saveWorkspace(workspace);

    return workspace;
  }

  async activate(id: string): Promise<void> {
    const workspace = this.workspaces.get(id);
    if (!workspace) throw new Error(`Workspace ${id} not found`);

    // 保存当前活动 workspace 的会话
    if (this.activeWorkspaceId) {
      await this.saveSession(this.activeWorkspaceId);
    }

    // 切换到新 workspace
    this.activeWorkspaceId = id;
    workspace.lastAccessedAt = Date.now();

    // 恢复新 workspace 的会话
    await this.restoreSession(id);

    // 通知 UI 更新
    this.emit("workspace-activated", workspace);
  }
}
```

---

### 2.2 Session Controller（会话控制器）

**职责：**

- 管理 Electron Session Partitions
- 确保会话隔离
- 处理 Cookie、LocalStorage、Cache

**关键实现：**

```typescript
interface ISessionController {
  getSession(workspaceId: string): Electron.Session;
  clearSession(workspaceId: string): Promise<void>;
  exportCookies(workspaceId: string): Promise<Cookie[]>;
  importCookies(workspaceId: string, cookies: Cookie[]): Promise<void>;
}

class SessionController implements ISessionController {
  private sessions: Map<string, Electron.Session> = new Map();

  getSession(workspaceId: string): Electron.Session {
    const workspace = workspaceManager.get(workspaceId);
    if (!workspace) throw new Error("Workspace not found");

    // 获取或创建 partition session
    if (!this.sessions.has(workspaceId)) {
      const session = electron.session.fromPartition(
        workspace.partition,
        { cache: true } // 持久化缓存
      );

      // 配置 session 安全策略
      this.configureSession(session, workspace);

      this.sessions.set(workspaceId, session);
    }

    return this.sessions.get(workspaceId)!;
  }

  private configureSession(
    session: Electron.Session,
    workspace: Workspace
  ): void {
    // 设置代理（如果配置）
    if (workspace.settings.proxy) {
      session.setProxy(workspace.settings.proxy);
    }

    // 设置 User-Agent（如果配置）
    if (workspace.settings.userAgent) {
      session.setUserAgent(workspace.settings.userAgent);
    }

    // 启用安全策略
    session.webRequest.onHeadersReceived((details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": ["default-src 'self'"],
        },
      });
    });

    // 可选：阻止第三方 Cookie
    if (workspace.settings.blockThirdPartyCookies) {
      session.cookies.on("changed", (event, cookie, cause, removed) => {
        // 实现第三方 Cookie 拦截逻辑
      });
    }
  }

  async clearSession(workspaceId: string): Promise<void> {
    const session = this.getSession(workspaceId);

    // 清除所有数据
    await session.clearStorageData({
      storages: ["cookies", "localstorage", "indexdb", "cache"],
    });
  }
}
```

---

### 2.3 WebView Pool Manager（视图池管理器）

**职责：**

- 管理 BrowserView 实例的创建和回收
- 实现 Tab 休眠和唤醒
- 内存优化

**核心逻辑：**

```typescript
interface IWebViewPoolManager {
  create(tab: Tab, workspace: Workspace): BrowserView;
  destroy(viewId: string): void;
  suspend(viewId: string): Promise<TabState>;
  resume(viewId: string, state: TabState): Promise<void>;
  getView(viewId: string): BrowserView | null;
}

class WebViewPoolManager implements IWebViewPoolManager {
  private activeViews: Map<string, BrowserView> = new Map();
  private suspendedStates: Map<string, TabState> = new Map();
  private maxActiveViews = 10; // 最多同时存在的 WebView

  create(tab: Tab, workspace: Workspace): BrowserView {
    // 如果超过上限，自动休眠最久未使用的
    if (this.activeViews.size >= this.maxActiveViews) {
      this.suspendLeastRecentlyUsed();
    }

    const view = new BrowserView({
      webPreferences: {
        partition: workspace.partition,
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: true,
        webSecurity: true,
        preload: path.join(__dirname, "preload.js"),
      },
    });

    // 加载 URL
    view.webContents.loadURL(tab.url);

    // 监听内存使用
    view.webContents.on("did-finish-load", () => {
      this.checkMemoryUsage(view);
    });

    this.activeViews.set(tab.id, view);
    tab.viewId = tab.id;

    return view;
  }

  async suspend(viewId: string): Promise<TabState> {
    const view = this.activeViews.get(viewId);
    if (!view) throw new Error("View not found");

    // 保存状态
    const state: TabState = {
      url: view.webContents.getURL(),
      title: view.webContents.getTitle(),
      scrollPosition: await this.getScrollPosition(view),
      timestamp: Date.now(),
    };

    // 销毁 BrowserView
    view.webContents.close();
    this.activeViews.delete(viewId);
    this.suspendedStates.set(viewId, state);

    return state;
  }

  async resume(viewId: string, state: TabState): Promise<void> {
    // 重新创建 BrowserView 并恢复状态
    const tab = tabManager.getTab(viewId);
    const workspace = workspaceManager.getActive();

    const view = this.create(tab, workspace);

    // 恢复滚动位置
    view.webContents.on("did-finish-load", () => {
      this.restoreScrollPosition(view, state.scrollPosition);
    });
  }

  private suspendLeastRecentlyUsed(): void {
    // 找到最久未访问的 Tab 并休眠
    const sorted = Array.from(this.activeViews.entries()).sort((a, b) => {
      const tabA = tabManager.getTab(a[0]);
      const tabB = tabManager.getTab(b[0]);
      return tabA.lastAccessedAt - tabB.lastAccessedAt;
    });

    if (sorted.length > 0) {
      const [viewId] = sorted[0];
      this.suspend(viewId);
    }
  }

  private async checkMemoryUsage(view: BrowserView): Promise<void> {
    const info = await view.webContents.getProcessMemoryInfo();

    // 如果单个 WebView 内存超过 500MB，记录警告
    if (info.private > 500 * 1024) {
      console.warn(`WebView using ${info.private / 1024}MB memory`);
    }
  }

  private async getScrollPosition(view: BrowserView): Promise<ScrollPosition> {
    return await view.webContents.executeJavaScript(`
      ({
        x: window.scrollX,
        y: window.scrollY
      })
    `);
  }

  private async restoreScrollPosition(
    view: BrowserView,
    position: ScrollPosition
  ): Promise<void> {
    await view.webContents.executeJavaScript(`
      window.scrollTo(${position.x}, ${position.y});
    `);
  }
}
```

---

### 2.4 Tab Manager（标签页管理器）

**职责：**

- Tab 的 CRUD
- Tab 状态管理
- Tab 分组和排序

```typescript
interface ITabManager {
  create(workspaceId: string, url: string): Promise<Tab>;
  close(tabId: string): Promise<void>;
  activate(tabId: string): Promise<void>;
  reorder(workspaceId: string, tabIds: string[]): Promise<void>;
  getTabsForWorkspace(workspaceId: string): Tab[];
}

class TabManager implements ITabManager {
  private tabs: Map<string, Tab> = new Map();

  async create(workspaceId: string, url: string): Promise<Tab> {
    const tab: Tab = {
      id: generateId(),
      workspaceId,
      url,
      title: "Loading...",
      favicon: "",
      active: false,
      suspended: false,
      createdAt: Date.now(),
      lastAccessedAt: Date.now(),
    };

    this.tabs.set(tab.id, tab);

    // 创建 BrowserView
    const workspace = workspaceManager.get(workspaceId);
    const view = webViewPoolManager.create(tab, workspace);

    // 监听标题和图标更新
    view.webContents.on("page-title-updated", (e, title) => {
      tab.title = title;
      this.emit("tab-updated", tab);
    });

    view.webContents.on("page-favicon-updated", (e, favicons) => {
      tab.favicon = favicons[0];
      this.emit("tab-updated", tab);
    });

    return tab;
  }

  async close(tabId: string): Promise<void> {
    const tab = this.tabs.get(tabId);
    if (!tab) return;

    // 销毁 BrowserView
    webViewPoolManager.destroy(tab.viewId);

    // 删除 Tab 记录
    this.tabs.delete(tabId);

    this.emit("tab-closed", tabId);
  }

  async activate(tabId: string): Promise<void> {
    const tab = this.tabs.get(tabId);
    if (!tab) throw new Error("Tab not found");

    // 如果 Tab 被休眠，先唤醒
    if (tab.suspended) {
      const state = webViewPoolManager.suspendedStates.get(tabId);
      await webViewPoolManager.resume(tabId, state);
      tab.suspended = false;
    }

    // 取消之前激活的 Tab
    const workspace = workspaceManager.get(tab.workspaceId);
    workspace.tabs.forEach((t) => (t.active = false));

    // 激活当前 Tab
    tab.active = true;
    tab.lastAccessedAt = Date.now();

    // 更新 BrowserWindow 的 BrowserView
    const view = webViewPoolManager.getView(tab.viewId);
    const mainWindow = BrowserWindow.getAllWindows()[0];
    mainWindow.setBrowserView(view);

    this.emit("tab-activated", tab);
  }
}
```

---

### 2.5 Plugin Host（插件宿主）

**职责：**

- 加载和卸载插件
- 管理插件生命周期
- 提供插件 API
- 权限控制

```typescript
interface IPluginHost {
  load(pluginPath: string): Promise<Plugin>;
  unload(pluginId: string): Promise<void>;
  getAPI(pluginId: string): PluginAPI;
  requestPermission(pluginId: string, permission: string): Promise<boolean>;
}

interface PluginAPI {
  // 生命周期钩子
  onWorkspaceActivated(callback: (ws: Workspace) => void): void;
  onTabCreated(callback: (tab: Tab) => void): void;
  onTabClosed(callback: (tabId: string) => void): void;

  // UI 扩展
  registerSidebarItem(config: SidebarItemConfig): void;
  registerContextMenuItem(config: MenuItemConfig): void;
  registerCommand(config: CommandConfig): void;

  // 数据访问
  storage: {
    get(key: string): Promise<any>;
    set(key: string, value: any): Promise<void>;
    delete(key: string): Promise<void>;
  };

  // WebView 交互（需要 tabs 权限）
  executeScript(tabId: string, code: string): Promise<any>;
  injectCSS(tabId: string, css: string): Promise<void>;

  // 网络拦截（需要 webRequest 权限）
  webRequest: {
    onBeforeRequest(filter: RequestFilter, callback: RequestCallback): void;
    onBeforeSendHeaders(filter: RequestFilter, callback: HeadersCallback): void;
  };

  // 通知
  showNotification(options: NotificationOptions): void;
}

class PluginHost implements IPluginHost {
  private plugins: Map<string, LoadedPlugin> = new Map();
  private permissionManager: PermissionManager;

  async load(pluginPath: string): Promise<Plugin> {
    // 读取 plugin.json
    const manifest = await this.readManifest(pluginPath);

    // 验证签名（如果启用）
    if (config.verifyPluginSignatures) {
      await this.verifySignature(pluginPath, manifest);
    }

    // 加载插件代码（在隔离的上下文中）
    const pluginCode = await fs.readFile(
      path.join(pluginPath, manifest.main),
      "utf-8"
    );

    const sandbox = this.createSandbox(manifest.id);
    const plugin = vm.runInContext(pluginCode, sandbox);

    // 注册插件
    this.plugins.set(manifest.id, {
      manifest,
      instance: plugin,
      context: sandbox,
    });

    // 调用插件初始化
    if (plugin.activate) {
      const api = this.createPluginAPI(manifest.id);
      await plugin.activate(api);
    }

    return manifest;
  }

  private createPluginAPI(pluginId: string): PluginAPI {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) throw new Error("Plugin not found");

    const api: PluginAPI = {
      onWorkspaceActivated: (callback) => {
        workspaceManager.on("workspace-activated", callback);
      },

      onTabCreated: (callback) => {
        tabManager.on("tab-created", callback);
      },

      registerSidebarItem: (config) => {
        // 检查权限
        if (!this.hasPermission(pluginId, "ui")) {
          throw new Error("Plugin lacks ui permission");
        }
        uiManager.registerSidebarItem(pluginId, config);
      },

      storage: {
        get: async (key: string) => {
          const fullKey = `plugin:${pluginId}:${key}`;
          return await storageManager.get(fullKey);
        },
        set: async (key: string, value: any) => {
          const fullKey = `plugin:${pluginId}:${key}`;
          await storageManager.set(fullKey, value);
        },
        delete: async (key: string) => {
          const fullKey = `plugin:${pluginId}:${key}`;
          await storageManager.delete(fullKey);
        },
      },

      executeScript: async (tabId: string, code: string) => {
        // 检查权限
        if (!this.hasPermission(pluginId, "tabs")) {
          throw new Error("Plugin lacks tabs permission");
        }

        const view = webViewPoolManager.getView(tabId);
        return await view.webContents.executeJavaScript(code);
      },

      webRequest: {
        onBeforeRequest: (filter, callback) => {
          if (!this.hasPermission(pluginId, "webRequest")) {
            throw new Error("Plugin lacks webRequest permission");
          }

          // 为这个插件注册拦截器
          this.registerWebRequestInterceptor(pluginId, filter, callback);
        },
      },

      showNotification: (options) => {
        new Notification({
          title: `[${plugin.manifest.name}] ${options.title}`,
          body: options.body,
        }).show();
      },
    };

    return api;
  }

  private createSandbox(pluginId: string): vm.Context {
    const sandbox = {
      console,
      setTimeout,
      setInterval,
      clearTimeout,
      clearInterval,
      fetch: this.createSafeFetch(pluginId),
      // 不暴露 require、process、__dirname 等
    };

    return vm.createContext(sandbox);
  }

  private hasPermission(pluginId: string, permission: string): boolean {
    const plugin = this.plugins.get(pluginId);
    return plugin.manifest.permissions?.includes(permission) || false;
  }
}
```

---

## 三、数据模型定义

### 3.1 核心数据结构

```typescript
// ============ Workspace ============
interface Workspace {
  id: string;
  name: string;
  icon: string; // 图标名称或 emoji
  color: string; // 十六进制颜色
  partition: string; // Electron session partition ID
  tabs: Tab[];
  settings: WorkspaceSettings;
  createdAt: number;
  lastAccessedAt: number;
  order?: number; // 排序
}

interface WorkspaceSettings {
  autoSuspendTabs: boolean;
  suspendAfterMinutes: number;
  proxy?: ProxyConfig;
  userAgent?: string;
  blockThirdPartyCookies?: boolean;
  enabledPlugins: string[];
  customCSS?: string;
}

interface ProxyConfig {
  mode: "direct" | "manual" | "pac_script";
  proxyRules?: string; // e.g., "http=proxy.com:8080"
  pacScript?: string;
}

// ============ Tab ============
interface Tab {
  id: string;
  workspaceId: string;
  url: string;
  title: string;
  favicon: string;
  active: boolean;
  suspended: boolean;
  viewId?: string; // BrowserView ID (undefined if suspended)
  state?: TabState; // 休眠时保存的状态
  createdAt: number;
  lastAccessedAt: number;
  tags?: string[]; // 用户自定义标签
  pinned?: boolean;
}

interface TabState {
  url: string;
  title: string;
  scrollPosition: ScrollPosition;
  timestamp: number;
}

interface ScrollPosition {
  x: number;
  y: number;
}

// ============ Plugin ============
interface Plugin {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  main: string; // 入口文件
  permissions: PluginPermission[];
  icon?: string;
  homepage?: string;
}

enum PluginPermission {
  STORAGE = "storage",
  TABS = "tabs",
  WEB_REQUEST = "webRequest",
  UI = "ui",
  CLIPBOARD = "clipboard",
  NOTIFICATIONS = "notifications",
}

interface LoadedPlugin {
  manifest: Plugin;
  instance: any; // 插件实例
  context: vm.Context; // VM 沙箱上下文
  enabled: boolean;
}

// ============ Config ============
interface AppConfig {
  version: string;
  firstRun: boolean;
  theme: "light" | "dark" | "system";
  language: string;
  workspaces: Workspace[];
  activeWorkspaceId: string | null;
  plugins: {
    enabled: string[];
    settings: Record<string, any>;
  };
  shortcuts: Record<string, string>;
  performance: {
    maxActiveViews: number;
    autoSuspendEnabled: boolean;
    suspendAfterMinutes: number;
  };
}
```

---

### 3.2 数据存储方案

```typescript
// ============ Storage Manager ============
interface IStorageManager {
  // Workspace 相关
  saveWorkspace(workspace: Workspace): Promise<void>;
  loadWorkspace(id: string): Promise<Workspace | null>;
  loadAllWorkspaces(): Promise<Workspace[]>;
  deleteWorkspace(id: string): Promise<void>;

  // 配置相关
  saveConfig(config: AppConfig): Promise<void>;
  loadConfig(): Promise<AppConfig>;

  // 会话相关
  saveSession(workspaceId: string, tabs: Tab[]): Promise<void>;
  loadSession(workspaceId: string): Promise<Tab[]>;

  // 插件数据
  getPluginData(pluginId: string, key: string): Promise<any>;
  setPluginData(pluginId: string, key: string, value: any): Promise<void>;
}

// 存储目录结构
/*
~/.digital-workspace/
├── config.json              # 全局配置
├── workspaces/              # Workspace 数据
│   ├── workspace-1.json
│   ├── workspace-2.json
│   └── ...
├── sessions/                # Session 持久化
│   ├── workspace-1/
│   │   └── partition-data/  # Electron partition 数据
│   └── workspace-2/
│       └── partition-data/
├── plugins/                 # 插件
│   ├── plugin-1/
│   │   ├── plugin.json
│   │   └── index.js
│   └── plugin-2/
└── logs/                    # 日志文件
    └── app.log
*/

class StorageManager implements IStorageManager {
  private basePath: string;
  private db: Database; // SQLite for metadata

  constructor() {
    this.basePath = app.getPath("userData");
    this.db = new Database(path.join(this.basePath, "app.db"));
    this.initDatabase();
  }

  private initDatabase(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS workspaces (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        icon TEXT,
        color TEXT,
        partition TEXT,
        settings TEXT,
        created_at INTEGER,
        last_accessed_at INTEGER,
        order_index INTEGER
      );
      
      CREATE TABLE IF NOT EXISTS tabs (
        id TEXT PRIMARY KEY,
        workspace_id TEXT NOT NULL,
        url TEXT NOT NULL,
        title TEXT,
        favicon TEXT,
        suspended INTEGER,
        state TEXT,
        created_at INTEGER,
        last_accessed_at INTEGER,
        FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE
      );
      
      CREATE TABLE IF NOT EXISTS plugin_data (
        plugin_id TEXT NOT NULL,
        key TEXT NOT NULL,
        value TEXT,
        PRIMARY KEY (plugin_id, key)
      );
    `);
  }

  async saveWorkspace(workspace: Workspace): Promise<void> {
    const stmt = this.db.prepare(`
      INSERT OR REPLACE INTO workspaces 
      (id, name, icon, color, partition, settings, created_at, last_accessed_at, order_index)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      workspace.id,
      workspace.name,
      workspace.icon,
      workspace.color,
      workspace.partition,
      JSON.stringify(workspace.settings),
      workspace.createdAt,
      workspace.lastAccessedAt,
      workspace.order || 0
    );
  }

  async loadWorkspace(id: string): Promise<Workspace | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM workspaces WHERE id = ?
    `);

    const row = stmt.get(id);
    if (!row) return null;

    // 加载 Tabs
    const tabs = await this.loadTabsForWorkspace(id);

    return {
      id: row.id,
      name: row.name,
      icon: row.icon,
      color: row.color,
      partition: row.partition,
      settings: JSON.parse(row.settings),
      tabs,
      createdAt: row.created_at,
      lastAccessedAt: row.last_accessed_at,
      order: row.order_index,
    };
  }

  private async loadTabsForWorkspace(workspaceId: string): Promise<Tab[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tabs WHERE workspace_id = ? ORDER BY created_at
    `);

    const rows = stmt.all(workspaceId);

    return rows.map((row) => ({
      id: row.id,
      workspaceId: row.workspace_id,
      url: row.url,
      title: row.title,
      favicon: row.favicon,
      active: false, // 活动状态不持久化
      suspended: Boolean(row.suspended),
      state: row.state ? JSON.parse(row.state) : undefined,
      createdAt: row.created_at,
      lastAccessedAt: row.last_accessed_at,
    }));
  }
}
```

---

## 四、IPC 通信架构

### 4.1 通信通道设计

```typescript
// ============ IPC Channels ============
enum IPCChannel {
  // Workspace
  WORKSPACE_CREATE = "workspace:create",
  WORKSPACE_UPDATE = "workspace:update",
  WORKSPACE_DELETE = "workspace:delete",
  WORKSPACE_ACTIVATE = "workspace:activate",
  WORKSPACE_LIST = "workspace:list",
  WORKSPACE_EXPORT = "workspace:export",
  WORKSPACE_IMPORT = "workspace:import",

  // Tab
  TAB_CREATE = "tab:create",
  TAB_CLOSE = "tab:close",
  TAB_ACTIVATE = "tab:activate",
  TAB_SUSPEND = "tab:suspend",
  TAB_RESUME = "tab:resume",
  TAB_NAVIGATE = "tab:navigate",

  // Plugin
  PLUGIN_LOAD = "plugin:load",
  PLUGIN_UNLOAD = "plugin:unload",
  PLUGIN_LIST = "plugin:list",
  PLUGIN_CALL = "plugin:call",

  // System
  APP_READY = "app:ready",
  APP_QUIT = "app:quit",
  WINDOW_MINIMIZE = "window:minimize",
  WINDOW_MAXIMIZE = "window:maximize",
  WINDOW_CLOSE = "window:close",
}

// ============ Main Process IPC Handler ============
class IPCHandler {
  register(): void {
    // Workspace handlers
    ipcMain.handle(
      IPCChannel.WORKSPACE_CREATE,
      async (event, config: WorkspaceConfig) => {
        return await workspaceManager.create(config);
      }
    );

    ipcMain.handle(IPCChannel.WORKSPACE_ACTIVATE, async (event, id: string) => {
      await workspaceManager.activate(id);
    });

    ipcMain.handle(IPCChannel.WORKSPACE_LIST, async () => {
      return await workspaceManager.list();
    });

    // Tab handlers
    ipcMain.handle(
      IPCChannel.TAB_CREATE,
      async (event, workspaceId: string, url: string) => {
        return await tabManager.create(workspaceId, url);
      }
    );

    ipcMain.handle(IPCChannel.TAB_ACTIVATE, async (event, tabId: string) => {
      await tabManager.activate(tabId);
    });

    // Plugin handlers
    ipcMain.handle(
      IPCChannel.PLUGIN_LOAD,
      async (event, pluginPath: string) => {
        return await pluginHost.load(pluginPath);
      }
    );

    // 监听事件并广播到 Renderer
    workspaceManager.on("workspace-activated", (workspace) => {
      BrowserWindow.getAllWindows().forEach((win) => {
        win.webContents.send("workspace-activated", workspace);
      });
    });

    tabManager.on("tab-updated", (tab) => {
      BrowserWindow.getAllWindows().forEach((win) => {
        win.webContents.send("tab-updated", tab);
      });
    });
  }
}
```

---

### 4.2 Preload Script（安全桥接）

```typescript
// preload.ts
import { contextBridge, ipcRenderer } from "electron";

// 暴露给 Renderer 的 API
const api = {
  // Workspace API
  workspace: {
    create: (config: WorkspaceConfig) =>
      ipcRenderer.invoke(IPCChannel.WORKSPACE_CREATE, config),
    update: (id: string, updates: Partial<WorkspaceConfig>) =>
      ipcRenderer.invoke(IPCChannel.WORKSPACE_UPDATE, id, updates),
    delete: (id: string) => ipcRenderer.invoke(IPCChannel.WORKSPACE_DELETE, id),
    activate: (id: string) =>
      ipcRenderer.invoke(IPCChannel.WORKSPACE_ACTIVATE, id),
    list: () => ipcRenderer.invoke(IPCChannel.WORKSPACE_LIST),
    export: (id: string) => ipcRenderer.invoke(IPCChannel.WORKSPACE_EXPORT, id),
    import: (data: WorkspaceExport) =>
      ipcRenderer.invoke(IPCChannel.WORKSPACE_IMPORT, data),

    // 事件监听
    onActivated: (callback: (workspace: Workspace) => void) => {
      ipcRenderer.on("workspace-activated", (event, workspace) =>
        callback(workspace)
      );
    },
  },

  // Tab API
  tab: {
    create: (workspaceId: string, url: string) =>
      ipcRenderer.invoke(IPCChannel.TAB_CREATE, workspaceId, url),
    close: (tabId: string) => ipcRenderer.invoke(IPCChannel.TAB_CLOSE, tabId),
    activate: (tabId: string) =>
      ipcRenderer.invoke(IPCChannel.TAB_ACTIVATE, tabId),
    navigate: (tabId: string, url: string) =>
      ipcRenderer.invoke(IPCChannel.TAB_NAVIGATE, tabId, url),

    // 事件监听
    onUpdated: (callback: (tab: Tab) => void) => {
      ipcRenderer.on("tab-updated", (event, tab) => callback(tab));
    },
    onCreated: (callback: (tab: Tab) => void) => {
      ipcRenderer.on("tab-created", (event, tab) => callback(tab));
    },
    onClosed: (callback: (tabId: string) => void) => {
      ipcRenderer.on("tab-closed", (event, tabId) => callback(tabId));
    },
  },

  // Plugin API
  plugin: {
    load: (pluginPath: string) =>
      ipcRenderer.invoke(IPCChannel.PLUGIN_LOAD, pluginPath),
    unload: (pluginId: string) =>
      ipcRenderer.invoke(IPCChannel.PLUGIN_UNLOAD, pluginId),
    list: () => ipcRenderer.invoke(IPCChannel.PLUGIN_LIST),
  },

  // System API
  system: {
    minimize: () => ipcRenderer.send(IPCChannel.WINDOW_MINIMIZE),
    maximize: () => ipcRenderer.send(IPCChannel.WINDOW_MAXIMIZE),
    close: () => ipcRenderer.send(IPCChannel.WINDOW_CLOSE),
    quit: () => ipcRenderer.send(IPCChannel.APP_QUIT),
  },
};

// 通过 contextBridge 暴露
contextBridge.exposeInMainWorld("electronAPI", api);

// TypeScript 类型声明
declare global {
  interface Window {
    electronAPI: typeof api;
  }
}
```

---

## 五、前端架构（React）

### 5.1 状态管理（Zustand）

```typescript
// ============ Store Definition ============
import create from "zustand";

interface AppState {
  // Workspace 状态
  workspaces: Workspace[];
  activeWorkspace: Workspace | null;

  // Tab 状态
  tabs: Tab[];
  activeTab: Tab | null;

  // UI 状态
  sidebarCollapsed: boolean;
  commandPaletteOpen: boolean;
  theme: "light" | "dark";

  // Actions
  setWorkspaces: (workspaces: Workspace[]) => void;
  setActiveWorkspace: (workspace: Workspace | null) => void;
  addWorkspace: (workspace: Workspace) => void;
  updateWorkspace: (id: string, updates: Partial<Workspace>) => void;
  removeWorkspace: (id: string) => void;

  setTabs: (tabs: Tab[]) => void;
  setActiveTab: (tab: Tab | null) => void;
  addTab: (tab: Tab) => void;
  updateTab: (id: string, updates: Partial<Tab>) => void;
  removeTab: (id: string) => void;

  toggleSidebar: () => void;
  toggleCommandPalette: () => void;
  setTheme: (theme: "light" | "dark") => void;
}

export const useAppStore = create<AppState>((set) => ({
  workspaces: [],
  activeWorkspace: null,
  tabs: [],
  activeTab: null,
  sidebarCollapsed: false,
  commandPaletteOpen: false,
  theme: "dark",

  setWorkspaces: (workspaces) => set({ workspaces }),
  setActiveWorkspace: (workspace) => set({ activeWorkspace: workspace }),
  addWorkspace: (workspace) =>
    set((state) => ({ workspaces: [...state.workspaces, workspace] })),
  updateWorkspace: (id, updates) =>
    set((state) => ({
      workspaces: state.workspaces.map((ws) =>
        ws.id === id ? { ...ws, ...updates } : ws
      ),
    })),
  removeWorkspace: (id) =>
    set((state) => ({
      workspaces: state.workspaces.filter((ws) => ws.id !== id),
    })),

  setTabs: (tabs) => set({ tabs }),
  setActiveTab: (tab) => set({ activeTab: tab }),
  addTab: (tab) => set((state) => ({ tabs: [...state.tabs, tab] })),
  updateTab: (id, updates) =>
    set((state) => ({
      tabs: state.tabs.map((t) => (t.id === id ? { ...t, ...updates } : t)),
    })),
  removeTab: (id) =>
    set((state) => ({
      tabs: state.tabs.filter((t) => t.id !== id),
    })),

  toggleSidebar: () =>
    set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed })),
  toggleCommandPalette: () =>
    set((state) => ({ commandPaletteOpen: !state.commandPaletteOpen })),
  setTheme: (theme) => set({ theme }),
}));
```

---

### 5.2 组件结构

```typescript
// ============ Component Hierarchy ============
/*
App
├── Sidebar
│   ├── WorkspaceList
│   │   └── WorkspaceItem
│   ├── AddWorkspaceButton
│   └── SettingsButton
├── MainContent
│   ├── TabBar
│   │   ├── TabItem
│   │   └── AddTabButton
│   └── WebViewContainer
│       └── (BrowserView 在这里显示，但由 Main Process 控制)
├── CommandPalette
└── StatusBar
*/

// ============ Key Components ============

// App.tsx
export function App() {
  const { activeWorkspace } = useAppStore();

  useEffect(() => {
    // 初始化：加载 Workspaces
    window.electronAPI.workspace.list().then((workspaces) => {
      useAppStore.getState().setWorkspaces(workspaces);
      if (workspaces.length > 0) {
        window.electronAPI.workspace.activate(workspaces[0].id);
      }
    });

    // 监听事件
    window.electronAPI.workspace.onActivated((workspace) => {
      useAppStore.getState().setActiveWorkspace(workspace);
      useAppStore.getState().setTabs(workspace.tabs);
    });

    window.electronAPI.tab.onUpdated((tab) => {
      useAppStore.getState().updateTab(tab.id, tab);
    });

    // 注册快捷键
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.key === "k") {
        e.preventDefault();
        useAppStore.getState().toggleCommandPalette();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  return (
    <div className="flex h-screen bg-gray-900 text-white">
      <Sidebar />
      <MainContent />
      {useAppStore((s) => s.commandPaletteOpen) && <CommandPalette />}
      <StatusBar />
    </div>
  );
}

// Sidebar.tsx
export function Sidebar() {
  const { workspaces, activeWorkspace, sidebarCollapsed } = useAppStore();

  const handleActivate = async (id: string) => {
    await window.electronAPI.workspace.activate(id);
  };

  return (
    <div
      className={`bg-gray-800 transition-all ${
        sidebarCollapsed ? "w-16" : "w-64"
      }`}
    >
      <div className="p-4">
        <h2 className="text-sm font-semibold text-gray-400 mb-4">
          {sidebarCollapsed ? "" : "WORKSPACES"}
        </h2>
        {workspaces.map((ws) => (
          <WorkspaceItem
            key={ws.id}
            workspace={ws}
            active={ws.id === activeWorkspace?.id}
            collapsed={sidebarCollapsed}
            onClick={() => handleActivate(ws.id)}
          />
        ))}
      </div>
    </div>
  );
}

// WorkspaceItem.tsx
interface WorkspaceItemProps {
  workspace: Workspace;
  active: boolean;
  collapsed: boolean;
  onClick: () => void;
}

export function WorkspaceItem({
  workspace,
  active,
  collapsed,
  onClick,
}: WorkspaceItemProps) {
  return (
    <button
      onClick={onClick}
      className={`
        w-full flex items-center gap-3 p-3 rounded-lg mb-2 transition-colors
        ${active ? "bg-blue-600" : "hover:bg-gray-700"}
      `}
    >
      <div
        className="w-8 h-8 rounded-lg flex items-center justify-center text-xl"
        style={{ backgroundColor: workspace.color }}
      >
        {workspace.icon}
      </div>
      {!collapsed && <span className="font-medium">{workspace.name}</span>}
    </button>
  );
}

// TabBar.tsx
export function TabBar() {
  const { tabs, activeTab } = useAppStore();
  const activeWorkspace = useAppStore((s) => s.activeWorkspace);

  const handleTabClick = async (tabId: string) => {
    await window.electronAPI.tab.activate(tabId);
  };

  const handleNewTab = async () => {
    if (!activeWorkspace) return;
    await window.electronAPI.tab.create(activeWorkspace.id, "about:blank");
  };

  return (
    <div className="bg-gray-800 flex items-center gap-2 px-2 py-1 overflow-x-auto">
      {tabs.map((tab) => (
        <TabItem
          key={tab.id}
          tab={tab}
          active={tab.id === activeTab?.id}
          onClick={() => handleTabClick(tab.id)}
        />
      ))}
      <button
        onClick={handleNewTab}
        className="px-3 py-1 hover:bg-gray-700 rounded"
      >
        +
      </button>
    </div>
  );
}
```

---

## 六、安全架构

### 6.1 安全原则

```typescript
// ============ Security Layers ============

/**
 * 1. Process Isolation
 * - Main Process: 完全权限
 * - Renderer Process: 无 Node.js 访问
 * - Preload: 受限的桥接 API
 * - BrowserView: 完全沙箱
 */

/**
 * 2. Content Security Policy
 */
const CSP = `
  default-src 'self';
  script-src 'self';
  style-src 'self' 'unsafe-inline';
  img-src 'self' data: https:;
  connect-src 'self' https:;
  font-src 'self' data:;
`;

/**
 * 3. Permissions
 */
interface PermissionRequest {
  permission: string;
  requestingOrigin: string;
  details: any;
}

class PermissionManager {
  private granted: Map<string, Set<string>> = new Map();

  async request(req: PermissionRequest): Promise<boolean> {
    // 检查是否已授权
    const key = `${req.requestingOrigin}:${req.permission}`;
    if (this.isGranted(key)) return true;

    // 弹窗询问用户
    const result = await dialog.showMessageBox({
      type: "question",
      buttons: ["Allow", "Deny"],
      title: "Permission Request",
      message: `${req.requestingOrigin} requests ${req.permission}`,
    });

    if (result.response === 0) {
      this.grant(key);
      return true;
    }

    return false;
  }

  private grant(key: string): void {
    const [origin, permission] = key.split(":");
    if (!this.granted.has(origin)) {
      this.granted.set(origin, new Set());
    }
    this.granted.get(origin)!.add(permission);
  }

  private isGranted(key: string): boolean {
    const [origin, permission] = key.split(":");
    return this.granted.get(origin)?.has(permission) || false;
  }
}
```

---

### 6.2 插件沙箱

```typescript
// ============ Plugin Sandbox ============

class PluginSandbox {
  createContext(pluginId: string): vm.Context {
    const sandbox = {
      // 基础 API
      console: {
        log: (...args: any[]) => console.log(`[Plugin:${pluginId}]`, ...args),
        error: (...args: any[]) =>
          console.error(`[Plugin:${pluginId}]`, ...args),
      },

      // 定时器（受限）
      setTimeout: (fn: Function, ms: number) => {
        if (ms < 0 || ms > 60000) {
          throw new Error("setTimeout: invalid delay");
        }
        return setTimeout(fn, ms);
      },

      // 网络请求（受限）
      fetch: this.createSafeFetch(pluginId),

      // 禁止的 API
      require: undefined,
      process: undefined,
      __dirname: undefined,
      __filename: undefined,
      global: undefined,
      Buffer: undefined,
    };

    return vm.createContext(sandbox);
  }

  private createSafeFetch(pluginId: string) {
    return async (url: string, options?: RequestInit): Promise<Response> => {
      // 检查 URL 白名单
      if (!this.isAllowedURL(pluginId, url)) {
        throw new Error(`Plugin ${pluginId} is not allowed to fetch ${url}`);
      }

      // 限流
      if (!(await this.checkRateLimit(pluginId))) {
        throw new Error("Rate limit exceeded");
      }

      return fetch(url, options);
    };
  }

  private isAllowedURL(pluginId: string, url: string): boolean {
    const plugin = pluginHost.getPlugin(pluginId);
    const allowedDomains = plugin?.manifest.allowedDomains || [];

    const urlObj = new URL(url);
    return allowedDomains.some((domain) => urlObj.hostname.endsWith(domain));
  }

  private async checkRateLimit(pluginId: string): Promise<boolean> {
    // 实现令牌桶算法
    // 每个插件每秒最多 10 个请求
    const key = `rate_limit:${pluginId}`;
    const bucket = rateLimiter.get(key) || {
      tokens: 10,
      lastRefill: Date.now(),
    };

    const now = Date.now();
    const elapsed = now - bucket.lastRefill;
    bucket.tokens = Math.min(10, bucket.tokens + elapsed / 100);
    bucket.lastRefill = now;

    if (bucket.tokens >= 1) {
      bucket.tokens -= 1;
      rateLimiter.set(key, bucket);
      return true;
    }

    return false;
  }
}
```

---

## 七、性能优化策略

### 7.1 内存管理

```typescript
// ============ Memory Manager ============

class MemoryManager {
  private maxTotalMemory = 2 * 1024 * 1024 * 1024; // 2GB
  private checkInterval = 30000; // 30 秒

  startMonitoring(): void {
    setInterval(() => this.check(), this.checkInterval);
  }

  private async check(): Promise<void> {
    const usage = await this.getTotalMemoryUsage();

    if (usage > this.maxTotalMemory) {
      console.warn(`Memory usage exceeded: ${usage / 1024 / 1024}MB`);
      await this.freeMemory();
    }
  }

  private async getTotalMemoryUsage(): Promise<number> {
    let total = 0;

    // Main process
    total += process.memoryUsage().heapUsed;

    // Renderer process
    for (const win of BrowserWindow.getAllWindows()) {
      const info = await win.webContents.getProcessMemoryInfo();
      total += info.private * 1024;
    }

    // BrowserViews
    for (const [id, view] of webViewPoolManager.activeViews) {
      const info = await view.webContents.getProcessMemoryInfo();
      total += info.private * 1024;
    }

    return total;
  }

  private async freeMemory(): Promise<void> {
    // 1. 休眠最久未使用的 Tabs
    const tabs = tabManager
      .getAllTabs()
      .filter((t) => !t.active && !t.suspended)
      .sort((a, b) => a.lastAccessedAt - b.lastAccessedAt);

    for (let i = 0; i < Math.min(5, tabs.length); i++) {
      await webViewPoolManager.suspend(tabs[i].id);
    }

    // 2. 清理不活跃 Workspace 的缓存
    for (const workspace of workspaceManager.list()) {
      if (workspace.id !== workspaceManager.getActive()?.id) {
        const session = sessionController.getSession(workspace.id);
        await session.clearCache();
      }
    }

    // 3. 强制垃圾回收（如果可用）
    if (global.gc) {
      global.gc();
    }
  }
}
```

---

### 7.2 启动优化

```typescript
// ============ Startup Optimizer ============

class StartupOptimizer {
  async optimize(): Promise<void> {
    // 1. 延迟加载非必要模块
    this.deferNonCriticalModules();

    // 2. 并行加载资源
    await Promise.all([
      this.loadWorkspaces(),
      this.loadPlugins(),
      this.loadConfig(),
    ]);

    // 3. 预热常用 Workspace
    this.preheatWorkspaces();
  }

  private deferNonCriticalModules(): void {
    // 延迟加载插件系统
    setTimeout(() => pluginHost.initialize(), 1000);

    // 延迟加载自动更新
    setTimeout(() => autoUpdater.checkForUpdates(), 5000);
  }

  private async preheatWorkspaces(): Promise<void> {
    const active = workspaceManager.getActive();
    if (!active) return;

    // 预先创建 session
    sessionController.getSession(active.id);

    // 预先创建第一个 Tab 的 WebView（如果存在）
    if (active.tabs.length > 0) {
      webViewPoolManager.create(active.tabs[0], active);
    }
  }
}
```

---

## 八、错误处理与日志

```typescript
// ============ Error Handler ============

class ErrorHandler {
  private logFile: string;

  constructor() {
    this.logFile = path.join(app.getPath("userData"), "logs", "app.log");
  }

  setup(): void {
    // 捕获未处理的错误
    process.on("uncaughtException", (error) => {
      this.log("FATAL", error);
      dialog.showErrorBox("Fatal Error", error.message);
    });

    process.on("unhandledRejection", (reason) => {
      this.log("ERROR", reason);
    });

    // Renderer process 错误
    app.on("render-process-gone", (event, webContents, details) => {
      this.log("ERROR", `Renderer process gone: ${details.reason}`);
    });
  }

  log(level: string, error: any): void {
    const timestamp = new Date().toISOString();
    const message = `[${timestamp}] [${level}] ${error.stack || error}\n`;

    console.error(message);
    fs.appendFileSync(this.logFile, message);
  }
}
```

---

## 九、关键技术决策总结

| 决策点       | 选择                     | 理由                         |
| ------------ | ------------------------ | ---------------------------- |
| 桌面框架     | Electron                 | 成熟、社区大、开发快         |
| 前端框架     | React + TypeScript       | 类型安全、生态丰富           |
| 状态管理     | Zustand                  | 轻量、简单、性能好           |
| 样式方案     | TailwindCSS              | 快速开发、一致性好           |
| 数据库       | SQLite                   | 嵌入式、无需服务器、性能好   |
| WebView      | BrowserView              | 性能优于 `<webview>`、更灵活 |
| Session 隔离 | Partition + 可选 Profile | 平衡性能与隔离程度           |
| 插件系统     | VM Sandbox               | 安全、可控、灵活             |
| IPC 通信     | contextBridge            | 符合 Electron 安全最佳实践   |

---

## 十、错误码与日志规范

**错误码分层：**

- UI（渲染进程）：`UI_*`（如 `UI_VALIDATION_ERROR`）
- IPC：`IPC_*`（如 `IPC_TIMEOUT`, `IPC_PAYLOAD_INVALID`）
- 主进程：`MAIN_*`（如 `MAIN_NOT_FOUND`, `MAIN_STATE_CONFLICT`）
- 插件：`PLUGIN_*`（如 `PLUGIN_PERMISSION_DENIED`）

**结构化日志（JSON 字段）：**

- `timestamp`、`level`（debug/info/warn/error）
- `module`（workspace|tab|session|webview|plugin）
- `event`/`code`、`message`
- `correlationId`（请求链路关联）
- `payloadSummary`（关键信息摘要，避免写入 PII）

**采样与隐私：**

- 默认不记录敏感数据（Cookie/Token/PII）；调试模式下依旧屏蔽
- 错误日志保留 `correlationId` 便于定位；详细数据通过本地调试工具查看

---

## 十一、Electron 安全开发清单

- 启用隔离：`contextIsolation: true`、`sandbox: true`、`nodeIntegration: false`
- 受限桥：仅在 `preload` 暴露白名单 API，所有入参校验与序列化
- CSP：默认 `default-src 'self'`，按站点白名单放行；阻断内联脚本
- WebView 导航拦截：校验目标 URL 所属 Workspace；黑名单域直接拒绝
- 协议注册限制：仅注册必要的自定义协议，禁止任意文件访问
- 插件沙箱与权限：见 `doc/插件系统设计文档.md`，最小权限 + 可审计

---

---

**文档版本：** v1.0  
**最后更新：** 20254-11-20  
**作者：** Claude & User
